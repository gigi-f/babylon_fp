import {
  AbstractMesh,
  Mesh
} from "./chunk-CUH3BMI7.js";
import {
  Matrix,
  Quaternion,
  Vector3
} from "./chunk-PPAXAS33.js";
import {
  BuildArray,
  Epsilon
} from "./chunk-JKI5MLKH.js";
import {
  VertexBuffer
} from "./chunk-VMQALS5J.js";
import {
  _WarnImport
} from "./chunk-OWCZTH5B.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Physics/v1/physicsJoint.js
var PhysicsJoint = class {
  /**
   * Initializes the physics joint
   * @param type The type of the physics joint
   * @param jointData The data for the physics joint
   */
  constructor(type, jointData) {
    this.type = type;
    this.jointData = jointData;
    jointData.nativeParams = jointData.nativeParams || {};
  }
  /**
   * Gets the physics joint
   */
  get physicsJoint() {
    return this._physicsJoint;
  }
  /**
   * Sets the physics joint
   */
  set physicsJoint(newJoint) {
    this._physicsJoint = newJoint;
  }
  /**
   * Sets the physics plugin
   */
  set physicsPlugin(physicsPlugin) {
    this._physicsPlugin = physicsPlugin;
  }
  /**
   * Execute a function that is physics-plugin specific.
   * @param {Function} func the function that will be executed.
   *                        It accepts two parameters: the physics world and the physics joint
   */
  executeNativeFunction(func) {
    func(this._physicsPlugin.world, this._physicsJoint);
  }
};
PhysicsJoint.DistanceJoint = 0;
PhysicsJoint.HingeJoint = 1;
PhysicsJoint.BallAndSocketJoint = 2;
PhysicsJoint.WheelJoint = 3;
PhysicsJoint.SliderJoint = 4;
PhysicsJoint.PrismaticJoint = 5;
PhysicsJoint.UniversalJoint = 6;
PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;
PhysicsJoint.PointToPointJoint = 8;
PhysicsJoint.SpringJoint = 9;
PhysicsJoint.LockJoint = 10;
var DistanceJoint = class extends PhysicsJoint {
  /**
   *
   * @param jointData The data for the Distance-Joint
   */
  constructor(jointData) {
    super(PhysicsJoint.DistanceJoint, jointData);
  }
  /**
   * Update the predefined distance.
   * @param maxDistance The maximum preferred distance
   * @param minDistance The minimum preferred distance
   */
  updateDistance(maxDistance, minDistance) {
    this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);
  }
};
var MotorEnabledJoint = class extends PhysicsJoint {
  /**
   * Initializes the Motor-Enabled Joint
   * @param type The type of the joint
   * @param jointData The physical joint data for the joint
   */
  constructor(type, jointData) {
    super(type, jointData);
  }
  /**
   * Set the motor values.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param force the force to apply
   * @param maxForce max force for this motor.
   */
  setMotor(force, maxForce) {
    this._physicsPlugin.setMotor(this, force || 0, maxForce);
  }
  /**
   * Set the motor's limits.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param upperLimit The upper limit of the motor
   * @param lowerLimit The lower limit of the motor
   */
  setLimit(upperLimit, lowerLimit) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
  }
};
var HingeJoint = class extends MotorEnabledJoint {
  /**
   * Initializes the Hinge-Joint
   * @param jointData The joint data for the Hinge-Joint
   */
  constructor(jointData) {
    super(PhysicsJoint.HingeJoint, jointData);
  }
  /**
   * Set the motor values.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param {number} force the force to apply
   * @param {number} maxForce max force for this motor.
   */
  setMotor(force, maxForce) {
    this._physicsPlugin.setMotor(this, force || 0, maxForce);
  }
  /**
   * Set the motor's limits.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param upperLimit The upper limit of the motor
   * @param lowerLimit The lower limit of the motor
   */
  setLimit(upperLimit, lowerLimit) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
  }
};
var Hinge2Joint = class extends MotorEnabledJoint {
  /**
   * Initializes the Hinge2-Joint
   * @param jointData The joint data for the Hinge2-Joint
   */
  constructor(jointData) {
    super(PhysicsJoint.Hinge2Joint, jointData);
  }
  /**
   * Set the motor values.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param targetSpeed the speed the motor is to reach
   * @param maxForce max force for this motor.
   * @param motorIndex motor's index, 0 or 1.
   */
  setMotor(targetSpeed, maxForce, motorIndex = 0) {
    this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);
  }
  /**
   * Set the motor limits.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param upperLimit the upper limit
   * @param lowerLimit lower limit
   * @param motorIndex the motor's index, 0 or 1.
   */
  setLimit(upperLimit, lowerLimit, motorIndex = 0) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsImpostor.js
Mesh._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
  return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {
    mass: jsonObject.physicsMass,
    friction: jsonObject.physicsFriction,
    restitution: jsonObject.physicsRestitution
  }, scene);
};
var PhysicsImpostor = class _PhysicsImpostor {
  /**
   * Specifies if the physics imposter is disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Gets the mass of the physics imposter
   */
  get mass() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;
  }
  set mass(value) {
    this.setMass(value);
  }
  /**
   * Gets the coefficient of friction
   */
  get friction() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;
  }
  /**
   * Sets the coefficient of friction
   */
  set friction(value) {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
  }
  /**
   * Gets the coefficient of restitution
   */
  get restitution() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;
  }
  /**
   * Sets the coefficient of restitution
   */
  set restitution(value) {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
  }
  /**
   * Gets the pressure of a soft body; only supported by the AmmoJSPlugin
   */
  get pressure() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPressure) {
      return 0;
    }
    return plugin.getBodyPressure(this);
  }
  /**
   * Sets the pressure of a soft body; only supported by the AmmoJSPlugin
   */
  set pressure(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPressure) {
      return;
    }
    plugin.setBodyPressure(this, value);
  }
  /**
   * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin
   */
  get stiffness() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyStiffness) {
      return 0;
    }
    return plugin.getBodyStiffness(this);
  }
  /**
   * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin
   */
  set stiffness(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyStiffness) {
      return;
    }
    plugin.setBodyStiffness(this, value);
  }
  /**
   * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
   */
  get velocityIterations() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyVelocityIterations) {
      return 0;
    }
    return plugin.getBodyVelocityIterations(this);
  }
  /**
   * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
   */
  set velocityIterations(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyVelocityIterations) {
      return;
    }
    plugin.setBodyVelocityIterations(this, value);
  }
  /**
   * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin
   */
  get positionIterations() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyPositionIterations) {
      return 0;
    }
    return plugin.getBodyPositionIterations(this);
  }
  /**
   * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin
   */
  set positionIterations(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPositionIterations) {
      return;
    }
    plugin.setBodyPositionIterations(this, value);
  }
  /**
   * Initializes the physics imposter
   * @param object The physics-enabled object used as the physics imposter
   * @param type The type of the physics imposter. Types are available as static members of this class.
   * @param _options The options for the physics imposter
   * @param _scene The Babylon scene
   */
  constructor(object, type, _options = { mass: 0 }, _scene) {
    this.object = object;
    this.type = type;
    this._options = _options;
    this._scene = _scene;
    this._pluginData = {};
    this._bodyUpdateRequired = false;
    this._onBeforePhysicsStepCallbacks = new Array();
    this._onAfterPhysicsStepCallbacks = new Array();
    this._onPhysicsCollideCallbacks = [];
    this._deltaPosition = Vector3.Zero();
    this._isDisposed = false;
    this.soft = false;
    this.segments = 0;
    this._tmpQuat = new Quaternion();
    this._tmpQuat2 = new Quaternion();
    this.beforeStep = () => {
      if (!this._physicsEngine) {
        return;
      }
      this.object.translate(this._deltaPosition, -1);
      if (this._deltaRotationConjugated && this.object.rotationQuaternion) {
        this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);
      }
      this.object.computeWorldMatrix(false);
      if (this.object.parent && this.object.rotationQuaternion) {
        this.getParentsRotation();
        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);
      } else {
        this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());
      }
      if (!this._options.disableBidirectionalTransformation) {
        if (this.object.rotationQuaternion) {
          this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(
            this,
            /*bInfo.boundingBox.centerWorld*/
            this.object.getAbsolutePosition(),
            this._tmpQuat
          );
        }
      }
      for (const func of this._onBeforePhysicsStepCallbacks) {
        func(this);
      }
    };
    this.afterStep = () => {
      if (!this._physicsEngine) {
        return;
      }
      for (const func of this._onAfterPhysicsStepCallbacks) {
        func(this);
      }
      this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);
      if (this.object.parent && this.object.rotationQuaternion) {
        this.getParentsRotation();
        this._tmpQuat.conjugateInPlace();
        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);
      }
      this.object.setAbsolutePosition(this.object.position);
      if (this._deltaRotation) {
        if (this.object.rotationQuaternion) {
          this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);
        }
        this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, _PhysicsImpostor._TmpVecs[0]);
        this.object.translate(_PhysicsImpostor._TmpVecs[0], 1);
      } else {
        this.object.translate(this._deltaPosition, 1);
      }
      this.object.computeWorldMatrix(true);
    };
    this.onCollideEvent = null;
    this.onCollide = (e) => {
      if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {
        return;
      }
      if (!this._physicsEngine) {
        return;
      }
      const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);
      if (otherImpostor) {
        if (this.onCollideEvent) {
          this.onCollideEvent(this, otherImpostor);
        }
        const callbacks = this._onPhysicsCollideCallbacks.filter((obj) => {
          return obj.otherImpostors.indexOf(otherImpostor) !== -1;
        });
        for (const obj of callbacks) {
          obj.callback(this, otherImpostor, e.point, e.distance, e.impulse, e.normal);
        }
      }
    };
    if (!this.object) {
      Logger.Error("No object was provided. A physics object is obligatory");
      return;
    }
    if (this.object.parent && _options.mass !== 0) {
      Logger.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.");
    }
    if (!this._scene && object.getScene) {
      this._scene = object.getScene();
    }
    if (!this._scene) {
      return;
    }
    if (this.type > 100) {
      this.soft = true;
    }
    this._physicsEngine = this._scene.getPhysicsEngine();
    if (!this._physicsEngine) {
      Logger.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
    } else {
      if (!this.object.rotationQuaternion) {
        if (this.object.rotation) {
          this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);
        } else {
          this.object.rotationQuaternion = new Quaternion();
        }
      }
      this._options.mass = _options.mass === void 0 ? 0 : _options.mass;
      this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;
      this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;
      if (this.soft) {
        this._options.mass = this._options.mass > 0 ? this._options.mass : 1;
        this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;
        this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;
        this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;
        this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;
        this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;
        this._options.margin = _options.margin === void 0 ? 0 : _options.margin;
        this._options.damping = _options.damping === void 0 ? 0 : _options.damping;
        this._options.path = _options.path === void 0 ? null : _options.path;
        this._options.shape = _options.shape === void 0 ? null : _options.shape;
      }
      this._joints = [];
      if (!this.object.parent || this._options.ignoreParent) {
        this._init();
      } else if (this.object.parent.physicsImpostor) {
        Logger.Warn("You must affect impostors to children before affecting impostor to parent.");
      }
    }
  }
  /**
   * This function will completely initialize this impostor.
   * It will create a new body - but only if this mesh has no parent.
   * If it has, this impostor will not be used other than to define the impostor
   * of the child mesh.
   * @internal
   */
  _init() {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.removeImpostor(this);
    this.physicsBody = null;
    this._parent = this._parent || this._getPhysicsParent();
    if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
      this._physicsEngine.addImpostor(this);
    }
  }
  _getPhysicsParent() {
    if (this.object.parent instanceof AbstractMesh) {
      const parentMesh = this.object.parent;
      return parentMesh.physicsImpostor;
    }
    return null;
  }
  /**
   * Should a new body be generated.
   * @returns boolean specifying if body initialization is required
   */
  isBodyInitRequired() {
    return this._bodyUpdateRequired || !this._physicsBody && (!this._parent || !!this._options.ignoreParent);
  }
  /**
   * Sets the updated scaling
   */
  setScalingUpdated() {
    this.forceUpdate();
  }
  /**
   * Force a regeneration of this or the parent's impostor's body.
   * Use with caution - This will remove all previously-instantiated joints.
   */
  forceUpdate() {
    this._init();
    if (this.parent && !this._options.ignoreParent) {
      this.parent.forceUpdate();
    }
  }
  /*public get mesh(): AbstractMesh {
      return this._mesh;
  }*/
  /**
   * Gets the body that holds this impostor. Either its own, or its parent.
   */
  get physicsBody() {
    return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;
  }
  /**
   * Get the parent of the physics imposter
   * @returns Physics imposter or null
   */
  get parent() {
    return !this._options.ignoreParent && this._parent ? this._parent : null;
  }
  /**
   * Sets the parent of the physics imposter
   */
  set parent(value) {
    this._parent = value;
  }
  /**
   * Set the physics body. Used mainly by the physics engine/plugin
   */
  set physicsBody(physicsBody) {
    if (this._physicsBody && this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
    }
    this._physicsBody = physicsBody;
    this.resetUpdateFlags();
  }
  /**
   * Resets the update flags
   */
  resetUpdateFlags() {
    this._bodyUpdateRequired = false;
  }
  /**
   * Gets the object extents
   * @returns the object extents
   */
  getObjectExtents() {
    if (this.object.getBoundingInfo) {
      const q = this.object.rotationQuaternion;
      const scaling = this.object.scaling.clone();
      this.object.rotationQuaternion = _PhysicsImpostor.IDENTITY_QUATERNION;
      const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
      if (worldMatrix) {
        worldMatrix.decompose(scaling, void 0, void 0);
      }
      const boundingInfo = this.object.getBoundingInfo();
      const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);
      size.x = Math.abs(size.x);
      size.y = Math.abs(size.y);
      size.z = Math.abs(size.z);
      this.object.rotationQuaternion = q;
      if (this.object.computeWorldMatrix) {
        this.object.computeWorldMatrix(true);
      }
      return size;
    } else {
      return _PhysicsImpostor.DEFAULT_OBJECT_SIZE;
    }
  }
  /**
   * Gets the object center
   * @returns The object center
   */
  getObjectCenter() {
    if (this.object.getBoundingInfo) {
      const boundingInfo = this.object.getBoundingInfo();
      return boundingInfo.boundingBox.centerWorld;
    } else {
      return this.object.position;
    }
  }
  /**
   * Get a specific parameter from the options parameters
   * @param paramName The object parameter name
   * @returns The object parameter
   */
  getParam(paramName) {
    return this._options[paramName];
  }
  /**
   * Sets a specific parameter in the options given to the physics plugin
   * @param paramName The parameter name
   * @param value The value of the parameter
   */
  setParam(paramName, value) {
    this._options[paramName] = value;
    this._bodyUpdateRequired = true;
  }
  /**
   * Specifically change the body's mass. Won't recreate the physics body object
   * @param mass The mass of the physics imposter
   */
  setMass(mass) {
    if (this.getParam("mass") !== mass) {
      this.setParam("mass", mass);
    }
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
    }
  }
  /**
   * Gets the linear velocity
   * @returns  linear velocity or null
   */
  getLinearVelocity() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();
  }
  /**
   * Sets the linear velocity
   * @param velocity  linear velocity or null
   */
  setLinearVelocity(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
    }
  }
  /**
   * Gets the angular velocity
   * @returns angular velocity or null
   */
  getAngularVelocity() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();
  }
  /**
   * Sets the angular velocity
   * @param velocity The velocity or null
   */
  setAngularVelocity(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
    }
  }
  /**
   * Execute a function with the physics plugin native code
   * Provide a function the will have two variables - the world object and the physics body object
   * @param func The function to execute with the physics plugin native code
   */
  executeNativeFunction(func) {
    if (this._physicsEngine) {
      func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
    }
  }
  /**
   * Register a function that will be executed before the physics world is stepping forward
   * @param func The function to execute before the physics world is stepped forward
   */
  registerBeforePhysicsStep(func) {
    this._onBeforePhysicsStepCallbacks.push(func);
  }
  /**
   * Unregister a function that will be executed before the physics world is stepping forward
   * @param func The function to execute before the physics world is stepped forward
   */
  unregisterBeforePhysicsStep(func) {
    const index = this._onBeforePhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onBeforePhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * Register a function that will be executed after the physics step
   * @param func The function to execute after physics step
   */
  registerAfterPhysicsStep(func) {
    this._onAfterPhysicsStepCallbacks.push(func);
  }
  /**
   * Unregisters a function that will be executed after the physics step
   * @param func The function to execute after physics step
   */
  unregisterAfterPhysicsStep(func) {
    const index = this._onAfterPhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onAfterPhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * register a function that will be executed when this impostor collides against a different body
   * @param collideAgainst Physics imposter, or array of physics imposters to collide against
   * @param func Callback that is executed on collision
   */
  registerOnPhysicsCollide(collideAgainst, func) {
    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
  }
  /**
   * Unregisters the physics imposter's collision callback
   * @param collideAgainst The physics object to collide against
   * @param func Callback to execute on collision
   */
  unregisterOnPhysicsCollide(collideAgainst, func) {
    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    let index = -1;
    const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {
      if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
        const sameList = cbDef.otherImpostors.every((impostor) => {
          return collidedAgainstList.indexOf(impostor) > -1;
        });
        if (sameList) {
          index = idx;
        }
        return sameList;
      }
      return false;
    });
    if (found) {
      this._onPhysicsCollideCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * Get the parent rotation
   * @returns The parent rotation
   */
  getParentsRotation() {
    let parent = this.object.parent;
    this._tmpQuat.copyFromFloats(0, 0, 0, 1);
    while (parent) {
      if (parent.rotationQuaternion) {
        this._tmpQuat2.copyFrom(parent.rotationQuaternion);
      } else {
        Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);
      }
      this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);
      parent = parent.parent;
    }
    return this._tmpQuat;
  }
  /**
   * Apply a force
   * @param force The force to apply
   * @param contactPoint The contact point for the force
   * @returns The physics imposter
   */
  applyForce(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
    }
    return this;
  }
  /**
   * Apply an impulse
   * @param force The impulse force
   * @param contactPoint The contact point for the impulse force
   * @returns The physics imposter
   */
  applyImpulse(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
    }
    return this;
  }
  /**
   * A help function to create a joint
   * @param otherImpostor A physics imposter used to create a joint
   * @param jointType The type of joint
   * @param jointData The data for the joint
   * @returns The physics imposter
   */
  createJoint(otherImpostor, jointType, jointData) {
    const joint = new PhysicsJoint(jointType, jointData);
    this.addJoint(otherImpostor, joint);
    return this;
  }
  /**
   * Add a joint to this impostor with a different impostor
   * @param otherImpostor A physics imposter used to add a joint
   * @param joint The joint to add
   * @returns The physics imposter
   */
  addJoint(otherImpostor, joint) {
    this._joints.push({
      otherImpostor,
      joint
    });
    if (this._physicsEngine) {
      this._physicsEngine.addJoint(this, otherImpostor, joint);
    }
    return this;
  }
  /**
   * Add an anchor to a cloth impostor
   * @param otherImpostor rigid impostor to anchor to
   * @param width ratio across width from 0 to 1
   * @param height ratio up height from 0 to 1
   * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch
   * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false
   * @returns impostor the soft imposter
   */
  addAnchor(otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  }
  /**
   * Add a hook to a rope impostor
   * @param otherImpostor rigid impostor to anchor to
   * @param length ratio across rope from 0 to 1
   * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch
   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
   * @returns impostor the rope imposter
   */
  addHook(otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  }
  /**
   * Will keep this body still, in a sleep mode.
   * @returns the physics imposter
   */
  sleep() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().sleepBody(this);
    }
    return this;
  }
  /**
   * Wake the body up.
   * @returns The physics imposter
   */
  wakeUp() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
    }
    return this;
  }
  /**
   * Clones the physics imposter
   * @param newObject The physics imposter clones to this physics-enabled object
   * @returns A nullable physics imposter
   */
  clone(newObject) {
    if (!newObject) {
      return null;
    }
    return new _PhysicsImpostor(newObject, this.type, this._options, this._scene);
  }
  /**
   * Disposes the physics imposter
   */
  dispose() {
    if (!this._physicsEngine) {
      return;
    }
    for (const j of this._joints) {
      if (this._physicsEngine) {
        this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);
      }
    }
    this._physicsEngine.removeImpostor(this);
    if (this.parent) {
      this.parent.forceUpdate();
    }
    this._isDisposed = true;
  }
  /**
   * Sets the delta position
   * @param position The delta position amount
   */
  setDeltaPosition(position) {
    this._deltaPosition.copyFrom(position);
  }
  /**
   * Sets the delta rotation
   * @param rotation The delta rotation amount
   */
  setDeltaRotation(rotation) {
    if (!this._deltaRotation) {
      this._deltaRotation = new Quaternion();
    }
    this._deltaRotation.copyFrom(rotation);
    this._deltaRotationConjugated = this._deltaRotation.conjugate();
  }
  /**
   * Gets the box size of the physics imposter and stores the result in the input parameter
   * @param result Stores the box size
   * @returns The physics imposter
   */
  getBoxSizeToRef(result) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
    }
    return this;
  }
  /**
   * Gets the radius of the physics imposter
   * @returns Radius of the physics imposter
   */
  getRadius() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;
  }
  /**
   * Sync a bone with this impostor
   * @param bone The bone to sync to the impostor.
   * @param boneMesh The mesh that the bone is influencing.
   * @param jointPivot The pivot of the joint / bone in local space.
   * @param distToJoint Optional distance from the impostor to the joint.
   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
   */
  syncBoneWithImpostor(bone, boneMesh, jointPivot, distToJoint, adjustRotation) {
    const tempVec = _PhysicsImpostor._TmpVecs[0];
    const mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = _PhysicsImpostor._TmpQuat;
        mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);
        bone.setRotationQuaternion(tempQuat, 1, boneMesh);
      } else {
        bone.setRotationQuaternion(mesh.rotationQuaternion, 1, boneMesh);
      }
    }
    tempVec.x = 0;
    tempVec.y = 0;
    tempVec.z = 0;
    if (jointPivot) {
      tempVec.x = jointPivot.x;
      tempVec.y = jointPivot.y;
      tempVec.z = jointPivot.z;
      bone.getDirectionToRef(tempVec, boneMesh, tempVec);
      if (distToJoint === void 0 || distToJoint === null) {
        distToJoint = jointPivot.length();
      }
      tempVec.x *= distToJoint;
      tempVec.y *= distToJoint;
      tempVec.z *= distToJoint;
    }
    if (bone.getParent()) {
      tempVec.addInPlace(mesh.getAbsolutePosition());
      bone.setAbsolutePosition(tempVec, boneMesh);
    } else {
      boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());
      boneMesh.position.x -= tempVec.x;
      boneMesh.position.y -= tempVec.y;
      boneMesh.position.z -= tempVec.z;
    }
  }
  /**
   * Sync impostor to a bone
   * @param bone The bone that the impostor will be synced to.
   * @param boneMesh The mesh that the bone is influencing.
   * @param jointPivot The pivot of the joint / bone in local space.
   * @param distToJoint Optional distance from the impostor to the joint.
   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
   * @param boneAxis Optional vector3 axis the bone is aligned with
   */
  syncImpostorWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {
    const mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = _PhysicsImpostor._TmpQuat;
        bone.getRotationQuaternionToRef(1, boneMesh, tempQuat);
        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);
      } else {
        bone.getRotationQuaternionToRef(1, boneMesh, mesh.rotationQuaternion);
      }
    }
    const pos = _PhysicsImpostor._TmpVecs[0];
    const boneDir = _PhysicsImpostor._TmpVecs[1];
    if (!boneAxis) {
      boneAxis = _PhysicsImpostor._TmpVecs[2];
      boneAxis.x = 0;
      boneAxis.y = 1;
      boneAxis.z = 0;
    }
    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);
    bone.getAbsolutePositionToRef(boneMesh, pos);
    if ((distToJoint === void 0 || distToJoint === null) && jointPivot) {
      distToJoint = jointPivot.length();
    }
    if (distToJoint !== void 0 && distToJoint !== null) {
      pos.x += boneDir.x * distToJoint;
      pos.y += boneDir.y * distToJoint;
      pos.z += boneDir.z * distToJoint;
    }
    mesh.setAbsolutePosition(pos);
  }
};
PhysicsImpostor.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);
PhysicsImpostor.IDENTITY_QUATERNION = Quaternion.Identity();
PhysicsImpostor._TmpVecs = BuildArray(3, Vector3.Zero);
PhysicsImpostor._TmpQuat = Quaternion.Identity();
PhysicsImpostor.NoImpostor = 0;
PhysicsImpostor.SphereImpostor = 1;
PhysicsImpostor.BoxImpostor = 2;
PhysicsImpostor.PlaneImpostor = 3;
PhysicsImpostor.MeshImpostor = 4;
PhysicsImpostor.CapsuleImpostor = 6;
PhysicsImpostor.CylinderImpostor = 7;
PhysicsImpostor.ParticleImpostor = 8;
PhysicsImpostor.HeightmapImpostor = 9;
PhysicsImpostor.ConvexHullImpostor = 10;
PhysicsImpostor.CustomImpostor = 100;
PhysicsImpostor.RopeImpostor = 101;
PhysicsImpostor.ClothImpostor = 102;
PhysicsImpostor.SoftbodyImpostor = 103;

// node_modules/@babylonjs/core/Physics/castingResult.js
var CastingResult = class {
  constructor() {
    this._hasHit = false;
    this._hitNormal = Vector3.Zero();
    this._hitPoint = Vector3.Zero();
    this._triangleIndex = -1;
  }
  /**
   * Gets the hit point.
   */
  get hitPoint() {
    return this._hitPoint;
  }
  /**
   * Gets the hit normal.
   */
  get hitNormal() {
    return this._hitNormal;
  }
  /**
   * Gets if there was a hit
   */
  get hasHit() {
    return this._hasHit;
  }
  /*
   * The index of the original triangle which was hit. Will be -1 if contact point is not on a mesh shape
   */
  get triangleIndex() {
    return this._triangleIndex;
  }
  /**
   * Sets the hit data
   * @param hitNormal defines the normal in world space
   * @param hitPoint defines the point in world space
   * @param triangleIndex defines the index of the triangle in case of mesh shape
   */
  setHitData(hitNormal, hitPoint, triangleIndex) {
    this._hasHit = true;
    this._hitNormal.set(hitNormal.x, hitNormal.y, hitNormal.z);
    this._hitPoint.set(hitPoint.x, hitPoint.y, hitPoint.z);
    this._triangleIndex = triangleIndex ?? -1;
  }
  /**
   * Resets all the values to default
   */
  reset() {
    this._hasHit = false;
    this._hitNormal.setAll(0);
    this._hitPoint.setAll(0);
    this._triangleIndex = -1;
    this.body = void 0;
    this.bodyIndex = void 0;
    this.shape = void 0;
  }
};

// node_modules/@babylonjs/core/Physics/physicsRaycastResult.js
var PhysicsRaycastResult = class extends CastingResult {
  constructor() {
    super(...arguments);
    this._hitDistance = 0;
    this._rayFromWorld = Vector3.Zero();
    this._rayToWorld = Vector3.Zero();
  }
  /**
   * Gets the distance from the hit
   */
  get hitDistance() {
    return this._hitDistance;
  }
  /**
   * Gets the hit normal/direction in the world
   */
  get hitNormalWorld() {
    return this._hitNormal;
  }
  /**
   * Gets the hit point in the world
   */
  get hitPointWorld() {
    return this._hitPoint;
  }
  /**
   * Gets the ray "start point" of the ray in the world
   */
  get rayFromWorld() {
    return this._rayFromWorld;
  }
  /**
   * Gets the ray "end point" of the ray in the world
   */
  get rayToWorld() {
    return this._rayToWorld;
  }
  /**
   * Sets the distance from the start point to the hit point
   * @param distance defines the distance to set
   */
  setHitDistance(distance) {
    this._hitDistance = distance;
  }
  /**
   * Calculates the distance manually
   */
  calculateHitDistance() {
    this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPoint);
  }
  /**
   * Resets all the values to default
   * @param from The from point on world space
   * @param to The to point on world space
   */
  reset(from = Vector3.Zero(), to = Vector3.Zero()) {
    super.reset();
    this._rayFromWorld.copyFrom(from);
    this._rayToWorld.copyFrom(to);
    this._hitDistance = 0;
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsEngine.js
var PhysicsEngine = class _PhysicsEngine {
  /**
   *
   * @returns version
   */
  getPluginVersion() {
    return this._physicsPlugin.getPluginVersion();
  }
  /**
   * @virtual
   * Factory used to create the default physics plugin.
   * @returns The default physics plugin
   */
  static DefaultPluginFactory() {
    throw _WarnImport("CannonJSPlugin");
  }
  /**
   * Creates a new Physics Engine
   * @param gravity defines the gravity vector used by the simulation
   * @param _physicsPlugin defines the plugin to use (CannonJS by default)
   */
  constructor(gravity, _physicsPlugin = _PhysicsEngine.DefaultPluginFactory()) {
    this._physicsPlugin = _physicsPlugin;
    this._impostors = [];
    this._joints = [];
    this._subTimeStep = 0;
    this._uniqueIdCounter = 0;
    if (!this._physicsPlugin.isSupported()) {
      throw new Error("Physics Engine " + this._physicsPlugin.name + " cannot be found. Please make sure it is included.");
    }
    gravity = gravity || new Vector3(0, -9.807, 0);
    this.setGravity(gravity);
    this.setTimeStep();
  }
  /**
   * Sets the gravity vector used by the simulation
   * @param gravity defines the gravity vector to use
   */
  setGravity(gravity) {
    this.gravity = gravity;
    this._physicsPlugin.setGravity(this.gravity);
  }
  /**
   * Set the time step of the physics engine.
   * Default is 1/60.
   * To slow it down, enter 1/600 for example.
   * To speed it up, 1/30
   * @param newTimeStep defines the new timestep to apply to this world.
   */
  setTimeStep(newTimeStep = 1 / 60) {
    this._physicsPlugin.setTimeStep(newTimeStep);
  }
  /**
   * Get the time step of the physics engine.
   * @returns the current time step
   */
  getTimeStep() {
    return this._physicsPlugin.getTimeStep();
  }
  /**
   * Set the sub time step of the physics engine.
   * Default is 0 meaning there is no sub steps
   * To increase physics resolution precision, set a small value (like 1 ms)
   * @param subTimeStep defines the new sub timestep used for physics resolution.
   */
  setSubTimeStep(subTimeStep = 0) {
    this._subTimeStep = subTimeStep;
  }
  /**
   * Get the sub time step of the physics engine.
   * @returns the current sub time step
   */
  getSubTimeStep() {
    return this._subTimeStep;
  }
  /**
   * Release all resources
   */
  dispose() {
    for (const impostor of this._impostors) {
      impostor.dispose();
    }
    this._physicsPlugin.dispose();
  }
  /**
   * Gets the name of the current physics plugin
   * @returns the name of the plugin
   */
  getPhysicsPluginName() {
    return this._physicsPlugin.name;
  }
  /**
   * Adding a new impostor for the impostor tracking.
   * This will be done by the impostor itself.
   * @param impostor the impostor to add
   */
  addImpostor(impostor) {
    this._impostors.push(impostor);
    impostor.uniqueId = this._uniqueIdCounter++;
    if (!impostor.parent) {
      this._physicsPlugin.generatePhysicsBody(impostor);
    }
  }
  /**
   * Remove an impostor from the engine.
   * This impostor and its mesh will not longer be updated by the physics engine.
   * @param impostor the impostor to remove
   */
  removeImpostor(impostor) {
    const index = this._impostors.indexOf(impostor);
    if (index > -1) {
      const removed = this._impostors.splice(index, 1);
      if (removed.length) {
        this.getPhysicsPlugin().removePhysicsBody(impostor);
      }
    }
  }
  /**
   * Add a joint to the physics engine
   * @param mainImpostor defines the main impostor to which the joint is added.
   * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint
   * @param joint defines the joint that will connect both impostors.
   */
  addJoint(mainImpostor, connectedImpostor, joint) {
    const impostorJoint = {
      mainImpostor,
      connectedImpostor,
      joint
    };
    joint.physicsPlugin = this._physicsPlugin;
    this._joints.push(impostorJoint);
    this._physicsPlugin.generateJoint(impostorJoint);
  }
  /**
   * Removes a joint from the simulation
   * @param mainImpostor defines the impostor used with the joint
   * @param connectedImpostor defines the other impostor connected to the main one by the joint
   * @param joint defines the joint to remove
   */
  removeJoint(mainImpostor, connectedImpostor, joint) {
    const matchingJoints = this._joints.filter(function(impostorJoint) {
      return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;
    });
    if (matchingJoints.length) {
      this._physicsPlugin.removeJoint(matchingJoints[0]);
    }
  }
  /**
   * Called by the scene. No need to call it.
   * @param delta defines the timespan between frames
   */
  _step(delta) {
    for (const impostor of this._impostors) {
      if (impostor.isBodyInitRequired()) {
        this._physicsPlugin.generatePhysicsBody(impostor);
      }
    }
    if (delta > 0.1) {
      delta = 0.1;
    } else if (delta <= 0) {
      delta = 1 / 60;
    }
    this._physicsPlugin.executeStep(delta, this._impostors);
  }
  /**
   * Gets the current plugin used to run the simulation
   * @returns current plugin
   */
  getPhysicsPlugin() {
    return this._physicsPlugin;
  }
  /**
   * Gets the list of physic impostors
   * @returns an array of PhysicsImpostor
   */
  getImpostors() {
    return this._impostors;
  }
  /**
   * Gets the impostor for a physics enabled object
   * @param object defines the object impersonated by the impostor
   * @returns the PhysicsImpostor or null if not found
   */
  getImpostorForPhysicsObject(object) {
    for (let i = 0; i < this._impostors.length; ++i) {
      if (this._impostors[i].object === object) {
        return this._impostors[i];
      }
    }
    return null;
  }
  /**
   * Gets the impostor for a physics body object
   * @param body defines physics body used by the impostor
   * @returns the PhysicsImpostor or null if not found
   */
  getImpostorWithPhysicsBody(body) {
    for (let i = 0; i < this._impostors.length; ++i) {
      if (this._impostors[i].physicsBody === body) {
        return this._impostors[i];
      }
    }
    return null;
  }
  /**
   * Does a raycast in the physics world
   * @param from when should the ray start?
   * @param to when should the ray end?
   * @returns PhysicsRaycastResult
   */
  raycast(from, to) {
    return this._physicsPlugin.raycast(from, to);
  }
  /**
   * Does a raycast in the physics world
   * @param from when should the ray start?
   * @param to when should the ray end?
   * @param result resulting PhysicsRaycastResult
   * @returns true if the ray hits an impostor, else false
   */
  raycastToRef(from, to, result) {
    return this._physicsPlugin.raycastToRef(from, to, result);
  }
};

// node_modules/@babylonjs/core/Physics/v1/Plugins/cannonJSPlugin.js
var CannonJSPlugin = class {
  constructor(_useDeltaForWorldStep = true, iterations = 10, cannonInjection = CANNON) {
    this._useDeltaForWorldStep = _useDeltaForWorldStep;
    this.name = "CannonJSPlugin";
    this._physicsMaterials = [];
    this._fixedTimeStep = 1 / 60;
    this._physicsBodiesToRemoveAfterStep = new Array();
    this._firstFrame = true;
    this._tmpQuaternion = new Quaternion();
    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);
    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);
    this._tmpPosition = Vector3.Zero();
    this._tmpDeltaPosition = Vector3.Zero();
    this._tmpUnityRotation = new Quaternion();
    this.BJSCANNON = cannonInjection;
    if (!this.isSupported()) {
      Logger.Error("CannonJS is not available. Please make sure you included the js file.");
      return;
    }
    this._extendNamespace();
    this.world = new this.BJSCANNON.World();
    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();
    this.world.solver.iterations = iterations;
    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();
    this._raycastResult = new PhysicsRaycastResult();
  }
  /**
   *
   * @returns plugin version
   */
  getPluginVersion() {
    return 1;
  }
  setGravity(gravity) {
    const vec = gravity;
    this.world.gravity.set(vec.x, vec.y, vec.z);
  }
  setTimeStep(timeStep) {
    this._fixedTimeStep = timeStep;
  }
  getTimeStep() {
    return this._fixedTimeStep;
  }
  executeStep(delta, impostors) {
    if (this._firstFrame) {
      this._firstFrame = false;
      for (const impostor of impostors) {
        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {
          impostor.beforeStep();
        }
      }
    }
    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);
    this._removeMarkedPhysicsBodiesFromWorld();
  }
  _removeMarkedPhysicsBodiesFromWorld() {
    if (this._physicsBodiesToRemoveAfterStep.length > 0) {
      for (const physicsBody of this._physicsBodiesToRemoveAfterStep) {
        if (typeof this.world.removeBody === "function") {
          this.world.removeBody(physicsBody);
        } else {
          this.world.remove(physicsBody);
        }
      }
      this._physicsBodiesToRemoveAfterStep.length = 0;
    }
  }
  applyImpulse(impostor, force, contactPoint) {
    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);
    impostor.physicsBody.applyImpulse(impulse, worldPoint);
  }
  applyForce(impostor, force, contactPoint) {
    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);
    impostor.physicsBody.applyForce(impulse, worldPoint);
  }
  generatePhysicsBody(impostor) {
    this._removeMarkedPhysicsBodiesFromWorld();
    if (impostor.parent) {
      if (impostor.physicsBody) {
        this.removePhysicsBody(impostor);
        impostor.forceUpdate();
      }
      return;
    }
    if (impostor.isBodyInitRequired()) {
      const shape = this._createShape(impostor);
      if (!shape) {
        Logger.Warn("It was not possible to create a physics body for this object.");
        return;
      }
      const oldBody = impostor.physicsBody;
      if (oldBody) {
        this.removePhysicsBody(impostor);
      }
      const material = this._addMaterial("mat-" + impostor.uniqueId, impostor.getParam("friction"), impostor.getParam("restitution"));
      const bodyCreationObject = {
        mass: impostor.getParam("mass"),
        material
      };
      const nativeOptions = impostor.getParam("nativeOptions");
      for (const key in nativeOptions) {
        if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {
          bodyCreationObject[key] = nativeOptions[key];
        }
      }
      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);
      impostor.physicsBody.addEventListener("collide", impostor.onCollide);
      this.world.addEventListener("preStep", impostor.beforeStep);
      this.world.addEventListener("postStep", impostor.afterStep);
      impostor.physicsBody.addShape(shape);
      if (typeof this.world.addBody === "function") {
        this.world.addBody(impostor.physicsBody);
      } else {
        this.world.add(impostor.physicsBody);
      }
      if (oldBody) {
        const props = ["force", "torque", "velocity", "angularVelocity"];
        for (const param of props) {
          const vec = oldBody[param];
          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);
        }
      }
      this._processChildMeshes(impostor);
    }
    this._updatePhysicsBodyTransformation(impostor);
  }
  _processChildMeshes(mainImpostor) {
    const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];
    const mainRotation = mainImpostor.object.rotationQuaternion;
    if (mainRotation) {
      mainRotation.conjugateToRef(this._tmpQuaternion);
    } else {
      this._tmpQuaternion.set(0, 0, 0, 1);
    }
    if (meshChildren.length) {
      const processMesh = (mesh) => {
        if (!mesh.rotationQuaternion) {
          return;
        }
        const childImpostor = mesh.getPhysicsImpostor();
        if (childImpostor) {
          const parent = childImpostor.parent;
          if (parent !== mainImpostor && mesh.parent) {
            const pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());
            const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);
            if (childImpostor.physicsBody) {
              this.removePhysicsBody(childImpostor);
              childImpostor.physicsBody = null;
            }
            childImpostor.parent = mainImpostor;
            childImpostor.resetUpdateFlags();
            mainImpostor.physicsBody.addShape(this._createShape(childImpostor), new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w));
            mainImpostor.physicsBody.mass += childImpostor.getParam("mass");
          }
        }
        const meshes2 = mesh.getChildMeshes(true).filter((m) => !!m.physicsImpostor);
        for (const mesh2 of meshes2) {
          processMesh(mesh2);
        }
      };
      const meshes = meshChildren.filter((m) => !!m.physicsImpostor);
      for (const mesh of meshes) {
        processMesh(mesh);
      }
    }
  }
  removePhysicsBody(impostor) {
    impostor.physicsBody.removeEventListener("collide", impostor.onCollide);
    this.world.removeEventListener("preStep", impostor.beforeStep);
    this.world.removeEventListener("postStep", impostor.afterStep);
    if (this._physicsBodiesToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {
      this._physicsBodiesToRemoveAfterStep.push(impostor.physicsBody);
    }
  }
  generateJoint(impostorJoint) {
    const mainBody = impostorJoint.mainImpostor.physicsBody;
    const connectedBody = impostorJoint.connectedImpostor.physicsBody;
    if (!mainBody || !connectedBody) {
      return;
    }
    let constraint;
    const jointData = impostorJoint.joint.jointData;
    const constraintData = {
      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,
      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,
      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,
      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,
      maxForce: jointData.nativeParams.maxForce,
      collideConnected: !!jointData.collision
    };
    switch (impostorJoint.joint.type) {
      case PhysicsJoint.HingeJoint:
      case PhysicsJoint.Hinge2Joint:
        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);
        break;
      case PhysicsJoint.DistanceJoint:
        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);
        break;
      case PhysicsJoint.SpringJoint: {
        const springData = jointData;
        constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {
          restLength: springData.length,
          stiffness: springData.stiffness,
          damping: springData.damping,
          localAnchorA: constraintData.pivotA,
          localAnchorB: constraintData.pivotB
        });
        break;
      }
      case PhysicsJoint.LockJoint:
        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);
        break;
      case PhysicsJoint.PointToPointJoint:
      case PhysicsJoint.BallAndSocketJoint:
      default:
        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);
        break;
    }
    constraint.collideConnected = !!jointData.collision;
    impostorJoint.joint.physicsJoint = constraint;
    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {
      this.world.addConstraint(constraint);
    } else {
      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function() {
        constraint.applyForce();
      };
      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);
    }
  }
  removeJoint(impostorJoint) {
    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {
      this.world.removeConstraint(impostorJoint.joint.physicsJoint);
    } else {
      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);
    }
  }
  _addMaterial(name, friction, restitution) {
    let index;
    let mat;
    for (index = 0; index < this._physicsMaterials.length; index++) {
      mat = this._physicsMaterials[index];
      if (mat.friction === friction && mat.restitution === restitution) {
        return mat;
      }
    }
    const currentMat = new this.BJSCANNON.Material(name);
    currentMat.friction = friction;
    currentMat.restitution = restitution;
    this._physicsMaterials.push(currentMat);
    return currentMat;
  }
  _checkWithEpsilon(value) {
    return value < Epsilon ? Epsilon : value;
  }
  _createShape(impostor) {
    const object = impostor.object;
    let returnValue;
    const impostorExtents = impostor.getObjectExtents();
    switch (impostor.type) {
      case PhysicsImpostor.SphereImpostor: {
        const radiusX = impostorExtents.x;
        const radiusY = impostorExtents.y;
        const radiusZ = impostorExtents.z;
        returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);
        break;
      }
      //TMP also for cylinder - TODO Cannon supports cylinder natively.
      case PhysicsImpostor.CylinderImpostor: {
        let nativeParams = impostor.getParam("nativeOptions");
        if (!nativeParams) {
          nativeParams = {};
        }
        const radiusTop = nativeParams.radiusTop !== void 0 ? nativeParams.radiusTop : this._checkWithEpsilon(impostorExtents.x) / 2;
        const radiusBottom = nativeParams.radiusBottom !== void 0 ? nativeParams.radiusBottom : this._checkWithEpsilon(impostorExtents.x) / 2;
        const height = nativeParams.height !== void 0 ? nativeParams.height : this._checkWithEpsilon(impostorExtents.y);
        const numSegments = nativeParams.numSegments !== void 0 ? nativeParams.numSegments : 16;
        returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);
        const quat = new this.BJSCANNON.Quaternion();
        quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);
        const translation = new this.BJSCANNON.Vec3(0, 0, 0);
        returnValue.transformAllPoints(translation, quat);
        break;
      }
      case PhysicsImpostor.BoxImpostor: {
        const box = impostorExtents.scale(0.5);
        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));
        break;
      }
      case PhysicsImpostor.PlaneImpostor:
        Logger.Warn("Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead");
        returnValue = new this.BJSCANNON.Plane();
        break;
      case PhysicsImpostor.MeshImpostor: {
        const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];
        const rawFaces = object.getIndices ? object.getIndices() : [];
        if (!rawVerts) {
          Logger.Warn("Tried to create a MeshImpostor for an object without vertices. This will fail.");
          return;
        }
        const oldPosition = object.position.clone();
        const oldRotation = object.rotation && object.rotation.clone();
        const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();
        object.position.copyFromFloats(0, 0, 0);
        object.rotation && object.rotation.copyFromFloats(0, 0, 0);
        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());
        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();
        const transform = object.computeWorldMatrix(true);
        const transformedVertices = [];
        let index;
        for (index = 0; index < rawVerts.length; index += 3) {
          Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(transformedVertices, index);
        }
        Logger.Warn("MeshImpostor only collides against spheres.");
        returnValue = new this.BJSCANNON.Trimesh(transformedVertices, rawFaces);
        object.position.copyFrom(oldPosition);
        oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);
        oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);
        break;
      }
      case PhysicsImpostor.HeightmapImpostor: {
        const oldPosition2 = object.position.clone();
        const oldRotation2 = object.rotation && object.rotation.clone();
        const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();
        object.position.copyFromFloats(0, 0, 0);
        object.rotation && object.rotation.copyFromFloats(0, 0, 0);
        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());
        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();
        object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);
        returnValue = this._createHeightmap(object);
        object.position.copyFrom(oldPosition2);
        oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);
        oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);
        object.computeWorldMatrix(true);
        break;
      }
      case PhysicsImpostor.ParticleImpostor:
        returnValue = new this.BJSCANNON.Particle();
        break;
      case PhysicsImpostor.NoImpostor:
        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));
        break;
    }
    return returnValue;
  }
  _createHeightmap(object, pointDepth) {
    let pos = object.getVerticesData(VertexBuffer.PositionKind);
    const transform = object.computeWorldMatrix(true);
    const transformedVertices = [];
    let index;
    for (index = 0; index < pos.length; index += 3) {
      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(transformedVertices, index);
    }
    pos = transformedVertices;
    const matrix = new Array();
    const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);
    const boundingInfo = object.getBoundingInfo();
    const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);
    const minY = boundingInfo.boundingBox.extendSizeWorld.z;
    const elementSize = dim * 2 / arraySize;
    for (let i = 0; i < pos.length; i = i + 3) {
      const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);
      const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);
      const y = -pos[i + 2] + minY;
      if (!matrix[x]) {
        matrix[x] = [];
      }
      if (!matrix[x][z]) {
        matrix[x][z] = y;
      }
      matrix[x][z] = Math.max(y, matrix[x][z]);
    }
    for (let x = 0; x <= arraySize; ++x) {
      if (!matrix[x]) {
        let loc = 1;
        while (!matrix[(x + loc) % arraySize]) {
          loc++;
        }
        matrix[x] = matrix[(x + loc) % arraySize].slice();
      }
      for (let z = 0; z <= arraySize; ++z) {
        if (!matrix[x][z]) {
          let loc = 1;
          let newValue;
          while (newValue === void 0) {
            newValue = matrix[x][(z + loc++) % arraySize];
          }
          matrix[x][z] = newValue;
        }
      }
    }
    const shape = new this.BJSCANNON.Heightfield(matrix, {
      elementSize
    });
    shape.minY = minY;
    return shape;
  }
  _updatePhysicsBodyTransformation(impostor) {
    const object = impostor.object;
    object.computeWorldMatrix && object.computeWorldMatrix(true);
    if (!object.getBoundingInfo()) {
      return;
    }
    const center = impostor.getObjectCenter();
    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));
    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);
    this._tmpPosition.copyFrom(center);
    let quaternion = object.rotationQuaternion;
    if (!quaternion) {
      return;
    }
    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {
      quaternion = quaternion.multiply(this._minus90X);
      impostor.setDeltaRotation(this._plus90X);
    }
    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {
      const mesh = object;
      let boundingInfo = mesh.getBoundingInfo();
      const rotationQuaternion = mesh.rotationQuaternion;
      mesh.rotationQuaternion = this._tmpUnityRotation;
      mesh.computeWorldMatrix(true);
      const c = center.clone();
      let oldPivot = mesh.getPivotMatrix();
      if (oldPivot) {
        oldPivot = oldPivot.clone();
      } else {
        oldPivot = Matrix.Identity();
      }
      const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);
      mesh.setPreTransformMatrix(p);
      mesh.computeWorldMatrix(true);
      boundingInfo = mesh.getBoundingInfo();
      const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();
      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);
      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));
      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;
      mesh.rotationQuaternion = rotationQuaternion;
      mesh.setPreTransformMatrix(oldPivot);
      mesh.computeWorldMatrix(true);
    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {
      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);
    }
    impostor.setDeltaPosition(this._tmpDeltaPosition);
    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);
    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
  }
  setTransformationFromPhysicsBody(impostor) {
    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);
    if (impostor.object.rotationQuaternion) {
      const q = impostor.physicsBody.quaternion;
      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);
    }
  }
  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {
    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);
    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);
  }
  isSupported() {
    return this.BJSCANNON !== void 0;
  }
  setLinearVelocity(impostor, velocity) {
    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);
  }
  setAngularVelocity(impostor, velocity) {
    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);
  }
  getLinearVelocity(impostor) {
    const v = impostor.physicsBody.velocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  }
  getAngularVelocity(impostor) {
    const v = impostor.physicsBody.angularVelocity;
    if (!v) {
      return null;
    }
    return new Vector3(v.x, v.y, v.z);
  }
  setBodyMass(impostor, mass) {
    impostor.physicsBody.mass = mass;
    impostor.physicsBody.updateMassProperties();
  }
  getBodyMass(impostor) {
    return impostor.physicsBody.mass;
  }
  getBodyFriction(impostor) {
    return impostor.physicsBody.material.friction;
  }
  setBodyFriction(impostor, friction) {
    impostor.physicsBody.material.friction = friction;
  }
  getBodyRestitution(impostor) {
    return impostor.physicsBody.material.restitution;
  }
  setBodyRestitution(impostor, restitution) {
    impostor.physicsBody.material.restitution = restitution;
  }
  sleepBody(impostor) {
    impostor.physicsBody.sleep();
  }
  wakeUpBody(impostor) {
    impostor.physicsBody.wakeUp();
  }
  updateDistanceJoint(joint, maxDistance) {
    joint.physicsJoint.distance = maxDistance;
  }
  setMotor(joint, speed, maxForce, motorIndex) {
    if (!motorIndex) {
      joint.physicsJoint.enableMotor();
      joint.physicsJoint.setMotorSpeed(speed);
      if (maxForce) {
        this.setLimit(joint, maxForce);
      }
    }
  }
  setLimit(joint, minForce, maxForce) {
    joint.physicsJoint.motorEquation.maxForce = maxForce;
    joint.physicsJoint.motorEquation.minForce = minForce === void 0 ? -minForce : minForce;
  }
  syncMeshWithImpostor(mesh, impostor) {
    const body = impostor.physicsBody;
    mesh.position.x = body.position.x;
    mesh.position.y = body.position.y;
    mesh.position.z = body.position.z;
    if (mesh.rotationQuaternion) {
      mesh.rotationQuaternion.x = body.quaternion.x;
      mesh.rotationQuaternion.y = body.quaternion.y;
      mesh.rotationQuaternion.z = body.quaternion.z;
      mesh.rotationQuaternion.w = body.quaternion.w;
    }
  }
  getRadius(impostor) {
    const shape = impostor.physicsBody.shapes[0];
    return shape.boundingSphereRadius;
  }
  getBoxSizeToRef(impostor, result) {
    const shape = impostor.physicsBody.shapes[0];
    result.x = shape.halfExtents.x * 2;
    result.y = shape.halfExtents.y * 2;
    result.z = shape.halfExtents.z * 2;
  }
  dispose() {
  }
  _extendNamespace() {
    const step_tmp1 = new this.BJSCANNON.Vec3();
    const engine = this.BJSCANNON;
    this.BJSCANNON.World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
      maxSubSteps = maxSubSteps || 10;
      timeSinceLastCalled = timeSinceLastCalled || 0;
      if (timeSinceLastCalled === 0) {
        this.internalStep(dt);
        this.time += dt;
      } else {
        let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;
        const t0 = performance.now();
        for (let i = 0; i !== internalSteps; i++) {
          this.internalStep(dt);
          if (performance.now() - t0 > dt * 1e3) {
            break;
          }
        }
        this.time += timeSinceLastCalled;
        const h = this.time % dt;
        const h_div_dt = h / dt;
        const interpvelo = step_tmp1;
        const bodies = this.bodies;
        for (let j = 0; j !== bodies.length; j++) {
          const b = bodies[j];
          if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {
            b.position.vsub(b.previousPosition, interpvelo);
            interpvelo.scale(h_div_dt, interpvelo);
            b.position.vadd(interpvelo, b.interpolatedPosition);
          } else {
            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);
            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);
          }
        }
      }
    };
  }
  /**
   * Does a raycast in the physics world
   * @param from when should the ray start?
   * @param to when should the ray end?
   * @returns PhysicsRaycastResult
   */
  raycast(from, to) {
    this._raycastResult.reset(from, to);
    this.raycastToRef(from, to, this._raycastResult);
    return this._raycastResult;
  }
  /**
   * Does a raycast in the physics world
   * @param from when should the ray start?
   * @param to when should the ray end?
   * @param result resulting PhysicsRaycastResult
   */
  raycastToRef(from, to, result) {
    this._cannonRaycastResult.reset();
    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);
    result.reset(from, to);
    if (this._cannonRaycastResult.hasHit) {
      result.setHitData({
        x: this._cannonRaycastResult.hitNormalWorld.x,
        y: this._cannonRaycastResult.hitNormalWorld.y,
        z: this._cannonRaycastResult.hitNormalWorld.z
      }, {
        x: this._cannonRaycastResult.hitPointWorld.x,
        y: this._cannonRaycastResult.hitPointWorld.y,
        z: this._cannonRaycastResult.hitPointWorld.z
      });
      result.setHitDistance(this._cannonRaycastResult.distance);
    }
  }
};
PhysicsEngine.DefaultPluginFactory = () => {
  return new CannonJSPlugin();
};

export {
  PhysicsJoint,
  DistanceJoint,
  MotorEnabledJoint,
  HingeJoint,
  Hinge2Joint,
  PhysicsImpostor,
  CastingResult,
  PhysicsRaycastResult,
  PhysicsEngine,
  CannonJSPlugin
};
//# sourceMappingURL=chunk-542H7J45.js.map
