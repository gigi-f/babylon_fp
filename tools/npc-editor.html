<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Babylon FP - NPC Editor</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #121212;
      color: #f1f1f1;
      padding: 24px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    h1 {
      color: #66bb6a;
      font-size: 2rem;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .intro {
      color: #b5b5b5;
      line-height: 1.6;
      background: #1f1f1f;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .toolbar {
      background: #1f1f1f;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #333;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    button {
      cursor: pointer;
      font-family: inherit;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2d2d2d;
      color: #f1f1f1;
      padding: 10px 16px;
      transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease;
    }

    button:hover {
      transform: translateY(-1px);
      border-color: #66bb6a;
      background: #343434;
    }

    button.danger {
      border-color: #d32f2f;
      color: #ffb4b4;
    }

    button.danger:hover {
      background: #3a1e1e;
    }

    .npc-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 18px;
    }

    .npc-card {
      background: #1f1f1f;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      transition: border 0.2s ease, transform 0.2s ease;
    }

    .npc-card:hover {
      border-color: #66bb6a;
      transform: translateY(-2px);
    }

    .npc-card h2 {
      font-size: 1.1rem;
      color: #f8f8f8;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field label {
      font-size: 0.85rem;
      color: #9d9d9d;
      letter-spacing: 0.5px;
    }

    .field input[type="text"],
    .field input[type="number"] {
      background: #161616;
      border: 1px solid #333;
      border-radius: 4px;
      color: #f1f1f1;
      padding: 8px 10px;
      font-family: inherit;
    }

    .color-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }

    .color-row input[type="color"] {
      border: none;
      width: 44px;
      height: 32px;
      padding: 0;
      background: none;
      cursor: pointer;
    }

    .color-preview {
      height: 32px;
      border-radius: 4px;
      border: 1px solid #333;
    }

    .card-actions {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin-top: 4px;
    }

    .export-section {
      background: #1f1f1f;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .export-section h2 {
      color: #66bb6a;
      font-size: 1.2rem;
    }

    #jsonOutput {
      width: 100%;
      min-height: 260px;
      background: #111;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 12px;
      font-family: 'Courier New', monospace;
      color: #7fffd4;
      font-size: 0.85rem;
      resize: vertical;
    }

    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    /* Face Editor Styles */
    .face-editor-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .face-editor-modal.active {
      display: flex;
    }

    .face-editor-content {
      background: #1f1f1f;
      border: 2px solid #66bb6a;
      border-radius: 12px;
      padding: 24px;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .face-editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #333;
      padding-bottom: 12px;
    }

    .face-editor-header h2 {
      color: #66bb6a;
      margin: 0;
    }

    .face-editor-body {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 24px;
      align-items: start;
    }

    .face-canvas-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    .face-canvas {
      border: 2px solid #666;
      border-radius: 4px;
      cursor: crosshair;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .face-preview {
      border: 2px solid #444;
      border-radius: 4px;
      image-rendering: pixelated;
    }

    .face-tools {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .tool-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .tool-group label {
      color: #aaa;
      font-size: 0.9rem;
      font-weight: bold;
    }

    .tool-buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .tool-button {
      padding: 8px;
      background: #2d2d2d;
      border: 2px solid #444;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }

    .tool-button:hover {
      background: #343434;
      border-color: #66bb6a;
    }

    .tool-button.active {
      background: #66bb6a;
      color: #121212;
      border-color: #66bb6a;
    }

    .color-palette {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
    }

    .palette-color {
      width: 40px;
      height: 40px;
      border: 2px solid #444;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .palette-color:hover {
      transform: scale(1.1);
      border-color: #66bb6a;
    }

    .palette-color.active {
      border-color: #66bb6a;
      border-width: 3px;
      box-shadow: 0 0 10px #66bb6a;
    }

    .brush-sizes {
      display: flex;
      gap: 8px;
    }

    .brush-size {
      width: 40px;
      height: 40px;
      border: 2px solid #444;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #2d2d2d;
      transition: all 0.2s;
    }

    .brush-size:hover {
      border-color: #66bb6a;
    }

    .brush-size.active {
      border-color: #66bb6a;
      background: #343434;
    }

    .brush-size-indicator {
      background: #f1f1f1;
      border-radius: 2px;
    }

    .face-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      border-top: 1px solid #333;
      padding-top: 16px;
    }

    .empty-state {
      background: #1f1f1f;
      border: 1px dashed #444;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      color: #888;
      font-size: 0.95rem;
    }

    .import-panel {
      margin-top: 12px;
      display: none;
      flex-direction: column;
      gap: 10px;
    }

    .import-panel.visible {
      display: flex;
    }

    #importInput {
      width: 100%;
      min-height: 140px;
      background: #101010;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 10px;
      font-family: 'Courier New', monospace;
      color: #f1f1f1;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #2b2b2b;
      color: #bdbdbd;
      font-size: 0.8rem;
    }

    @media (max-width: 720px) {
      .npc-list {
        grid-template-columns: 1fr;
      }

      .card-actions {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üßë‚Äçü§ù‚Äçüßë Babylon FP NPC Editor</h1>
    <p class="intro">
      Create and customize NPC definitions for the game. Adjust name, ID, shirt color, and pants color for every character.
      When you are ready, export the JSON and drop the files into <code>public/data/npcs</code>.
    </p>

    <div class="toolbar">
      <button id="addNpcBtn">‚ûï Add NPC</button>
      <button id="resetDefaultsBtn">üîÑ Reset to defaults</button>
      <button id="toggleImportBtn">üì• Import JSON</button>
      <button id="clearAllBtn" class="danger">üóëÔ∏è Clear all</button>
      <span class="pill" id="npcCountPill"></span>
    </div>

    <div id="npcList" class="npc-list"></div>

    <div class="export-section">
      <h2>Export NPC JSON</h2>
      <textarea id="jsonOutput" readonly></textarea>
      <div class="action-buttons">
        <button id="copyJsonBtn">üìã Copy JSON</button>
        <button id="downloadJsonBtn">üíæ Download JSON</button>
      </div>
      <div id="importPanel" class="import-panel">
        <textarea id="importInput" placeholder='Paste an array of NPC definitions or an object with a "npcs" array'></textarea>
        <div class="action-buttons">
          <button id="applyImportBtn">Apply import</button>
          <button id="cancelImportBtn">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Face Editor Modal -->
  <div id="faceEditorModal" class="face-editor-modal">
    <div class="face-editor-content">
      <div class="face-editor-header">
        <h2>‚úèÔ∏è Face Editor</h2>
        <button id="closeFaceEditor" style="padding: 8px 16px;">‚úï Close</button>
      </div>
      <div class="face-editor-body">
        <div class="face-canvas-container">
          <canvas id="faceCanvas" class="face-canvas" width="512" height="512"></canvas>
          <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
            <label style="color: #aaa; font-size: 0.9rem;">Preview (128x128)</label>
            <canvas id="facePreview" class="face-preview" width="128" height="128"></canvas>
          </div>
        </div>
        <div class="face-tools">
          <div class="tool-group">
            <label>Tool</label>
            <div class="tool-buttons">
              <button class="tool-button active" data-tool="draw">‚úèÔ∏è Draw</button>
              <button class="tool-button" data-tool="erase">üßπ Erase</button>
              <button class="tool-button" data-tool="fill">ü™£ Fill</button>
              <button class="tool-button" data-tool="eyedropper">üíß Pick Color</button>
            </div>
          </div>
          <div class="tool-group">
            <label>Brush Size</label>
            <div class="brush-sizes">
              <button class="brush-size active" data-size="1" title="1x1 (Single pixel)">
                <div class="brush-size-indicator" style="width: 4px; height: 4px;"></div>
              </button>
              <button class="brush-size" data-size="2" title="2x2 (Small)">
                <div class="brush-size-indicator" style="width: 8px; height: 8px;"></div>
              </button>
              <button class="brush-size" data-size="8" title="8x8 (Large)">
                <div class="brush-size-indicator" style="width: 20px; height: 20px;"></div>
              </button>
              <button class="brush-size" data-size="16" title="16x16 (XL - Eye size)">
                <div class="brush-size-indicator" style="width: 32px; height: 32px;"></div>
              </button>
            </div>
          </div>
          <div class="tool-group">
            <label>Color Palette</label>
            <div class="color-palette">
              <div class="palette-color active" style="background: #000000;" data-color="#000000" title="Black"></div>
              <div class="palette-color" style="background: #FFFFFF;" data-color="#FFFFFF" title="White"></div>
              <div class="palette-color" style="background: #8B4513;" data-color="#8B4513" title="Brown"></div>
              <div class="palette-color" style="background: #4169E1;" data-color="#4169E1" title="Blue"></div>
              <div class="palette-color" style="background: #228B22;" data-color="#228B22" title="Green"></div>
              <div class="palette-color" style="background: #FF0000;" data-color="#FF0000" title="Red"></div>
              <div class="palette-color" style="background: #FFD700;" data-color="#FFD700" title="Gold"></div>
              <div class="palette-color" style="background: #FF69B4;" data-color="#FF69B4" title="Pink"></div>
              <div class="palette-color" style="background: #808080;" data-color="#808080" title="Gray"></div>
              <div class="palette-color" style="background: #A0522D;" data-color="#A0522D" title="Sienna"></div>
              <div class="palette-color" style="background: #DEB887;" data-color="#DEB887" title="Tan"></div>
              <div class="palette-color" style="background: #9370DB;" data-color="#9370DB" title="Purple"></div>
            </div>
            <div style="margin-top: 8px;">
              <label style="display: block; margin-bottom: 4px; font-size: 0.85rem;">Custom Color:</label>
              <input type="color" id="customColorPicker" style="width: 100%; height: 40px; cursor: pointer; border-radius: 6px;">
            </div>
          </div>
          <div class="tool-group">
            <label>Actions</label>
            <div class="tool-buttons">
              <button id="clearFaceBtn" class="tool-button">üóëÔ∏è Clear</button>
              <button id="defaultFaceBtn" class="tool-button">üòä Default Face</button>
            </div>
          </div>
        </div>
      </div>
      <div class="face-actions">
        <button id="cancelFaceBtn" style="padding: 10px 20px;">Cancel</button>
        <button id="saveFaceBtn" style="padding: 10px 20px; background: #66bb6a;">üíæ Save Face</button>
      </div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = 'babylon-fp-npc-editor-v1';

    /**
     * Default NPC definitions mirroring the files in public/data/npcs
     */
    const defaultNpcDefinitions = [
      {
        id: 'npc_baker',
        name: 'Baker Bob',
        color: [0.9, 0.7, 0.5],
        shirtColor: [0.82, 0.45, 0.2],
        pantsColor: [0.45, 0.3, 0.18],
        speed: 1.5,
        schedule: {
          '21600': { x: 0, y: 0, z: 0 },
          '26100': { x: 2, y: 0, z: 2 }
        },
        metadata: {
          role: 'merchant',
          shop: 'bakery',
          dialogue: 'Fresh bread, get your fresh bread!',
          activeHours: '6:00-18:00'
        }
      },
      {
        id: 'npc_guard',
        name: 'Night Watchman',
        color: [0.8, 0.78, 0.74],
        shirtColor: [0.2, 0.2, 0.8],
        pantsColor: [0.12, 0.12, 0.45],
        speed: 2.0,
        schedule: {
          '0': { x: -10, y: 0, z: 0 },
          '1800': { x: 0, y: 0, z: 10 },
          '3600': { x: 10, y: 0, z: 0 },
          '5400': { x: 0, y: 0, z: -10 },
          '7200': { x: -10, y: 0, z: 0 }
        },
        metadata: {
          role: 'guard',
          patrol: 'town_square',
          dialogue: 'Stay out of trouble!',
          activeHours: '18:00-06:00'
        }
      },
      {
        id: 'npc_beggar',
        name: 'Hungry Joe',
        color: [0.85, 0.72, 0.6],
        shirtColor: [0.5, 0.4, 0.3],
        pantsColor: [0.2, 0.2, 0.2],
        speed: 1.0,
        schedule: {
          '0': { x: 7, y: 0, z: 8 },
          '2400': { x: 6, y: 0, z: 6 },
          '4800': { x: 7, y: 0, z: 8 }
        },
        metadata: {
          role: 'beggar',
          state: 'desperate',
          dialogue: 'Spare some change?',
          activeHours: 'all'
        }
      }
    ];

    const npcListEl = document.getElementById('npcList');
    const jsonOutputEl = document.getElementById('jsonOutput');
    const npcCountPill = document.getElementById('npcCountPill');
    const importPanel = document.getElementById('importPanel');
    const importInput = document.getElementById('importInput');

    let npcs = [];

    function clamp01(value) {
      return Math.min(1, Math.max(0, value));
    }

    function colorArrayToHex(arr) {
      if (!Array.isArray(arr) || arr.length !== 3) return '#aaaaaa';
      const [r, g, b] = arr.map(channel => clamp01(channel));
      const toHex = (val) => {
        const n = Math.round(val * 255);
        return n.toString(16).padStart(2, '0');
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function hexToColorArray(hex) {
      if (typeof hex !== 'string') return [0.7, 0.7, 0.7];
      const normalized = hex.trim().replace('#', '');
      if (normalized.length === 3) {
        const r = parseInt(normalized[0] + normalized[0], 16);
        const g = parseInt(normalized[1] + normalized[1], 16);
        const b = parseInt(normalized[2] + normalized[2], 16);
        return [r / 255, g / 255, b / 255];
      }
      if (normalized.length !== 6 || Number.isNaN(Number(`0x${normalized}`))) {
        return [0.7, 0.7, 0.7];
      }
      return [
        parseInt(normalized.slice(0, 2), 16) / 255,
        parseInt(normalized.slice(2, 4), 16) / 255,
        parseInt(normalized.slice(4, 6), 16) / 255
      ];
    }

    function clone(value) {
      return JSON.parse(JSON.stringify(value));
    }

    function normalizeDefinition(def) {
      const shirtArray = def.shirtColor ?? def.color ?? [0.3, 0.4, 0.8];
      const pantsArray = def.pantsColor ?? shirtArray.map(channel => clamp01(channel * 0.6));
      const normalized = {
        id: def.id ?? generateNpcId(),
        name: def.name ?? 'Unnamed NPC',
        skinColor: colorArrayToHex(def.color ?? [0.85, 0.75, 0.6]),
        shirtColor: colorArrayToHex(shirtArray),
        pantsColor: colorArrayToHex(pantsArray),
        speed: typeof def.speed === 'number' ? def.speed : 1.5,
        schedule: clone(def.schedule ?? { '0': { x: 0, y: 0, z: 0 } }),
        metadata: clone(def.metadata ?? {})
      };
      // Preserve face data if it exists
      if (def.faceData) {
        normalized.faceData = def.faceData;
      }
      return normalized;
    }

    function normalizeStoredNpc(npc) {
      if (!npc) return normalizeDefinition({});
      if (npc.skinColor && npc.shirtColor && npc.pantsColor) {
        const normalized = {
          id: npc.id ?? generateNpcId(),
          name: npc.name ?? 'Unnamed NPC',
          skinColor: npc.skinColor,
          shirtColor: npc.shirtColor,
          pantsColor: npc.pantsColor,
          speed: typeof npc.speed === 'number' ? npc.speed : 1.5,
          schedule: clone(npc.schedule ?? { '0': { x: 0, y: 0, z: 0 } }),
          metadata: clone(npc.metadata ?? {})
        };
        // Preserve face data if it exists
        if (npc.faceData) {
          normalized.faceData = npc.faceData;
        }
        return normalized;
      }
      return normalizeDefinition(npc);
    }

    function generateNpcId() {
      return `npc_custom_${Math.random().toString(36).slice(2, 8)}`;
    }

    function persist() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(npcs));
    }

    function updateNpcCount() {
      const count = npcs.length;
      npcCountPill.textContent = count === 1 ? '1 NPC' : `${count} NPCs`;
    }

    function renderNpcList() {
      npcListEl.innerHTML = '';

      if (npcs.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.innerHTML = 'No NPCs yet. Click <strong>"Add NPC"</strong> to create one.';
        npcListEl.appendChild(empty);
        updateNpcCount();
        updateJsonOutput();
        return;
      }

      npcs.forEach((npc, index) => {
        const card = document.createElement('div');
        card.className = 'npc-card';
        const idSuffix = `npc-${index}`;
        card.innerHTML = `
          <h2>${npc.name || 'Unnamed NPC'}</h2>
          <div class="field">
            <label for="${idSuffix}-id">NPC ID</label>
            <input type="text" id="${idSuffix}-id" value="${npc.id}" />
          </div>
          <div class="field">
            <label for="${idSuffix}-name">Display name</label>
            <input type="text" id="${idSuffix}-name" value="${npc.name}" />
          </div>
          <div class="field">
            <label for="${idSuffix}-skin">Skin tone</label>
            <div class="color-row">
              <input type="color" id="${idSuffix}-skin" value="${npc.skinColor}" />
              <div class="color-preview" style="background:${npc.skinColor}"></div>
            </div>
          </div>
          <div class="field">
            <label for="${idSuffix}-shirt">Shirt color</label>
            <div class="color-row">
              <input type="color" id="${idSuffix}-shirt" value="${npc.shirtColor}" />
              <div class="color-preview" style="background:${npc.shirtColor}"></div>
            </div>
          </div>
          <div class="field">
            <label for="${idSuffix}-pants">Pants color</label>
            <div class="color-row">
              <input type="color" id="${idSuffix}-pants" value="${npc.pantsColor}" />
              <div class="color-preview" style="background:${npc.pantsColor}"></div>
            </div>
          </div>
          <div class="field">
            <label for="${idSuffix}-speed">Speed (units/s)</label>
            <input type="number" step="0.1" min="0.1" id="${idSuffix}-speed" value="${npc.speed}" />
          </div>
          <div class="field">
            <label>Face</label>
            <button data-action="edit-face" style="width: 100%; padding: 10px; background: #4169E1; border-color: #4169E1;">
              ‚úèÔ∏è Edit Face
            </button>
          </div>
          <div class="card-actions">
            <button data-action="duplicate">Duplicate</button>
            <button data-action="delete" class="danger">Remove</button>
          </div>
        `;

        npcListEl.appendChild(card);

        const idInput = card.querySelector(`#${idSuffix}-id`);
        const nameInput = card.querySelector(`#${idSuffix}-name`);
        const skinInput = card.querySelector(`#${idSuffix}-skin`);
        const shirtInput = card.querySelector(`#${idSuffix}-shirt`);
        const pantsInput = card.querySelector(`#${idSuffix}-pants`);
        const speedInput = card.querySelector(`#${idSuffix}-speed`);
        const editFaceBtn = card.querySelector('[data-action="edit-face"]');
        const duplicateBtn = card.querySelector('[data-action="duplicate"]');
        const deleteBtn = card.querySelector('[data-action="delete"]');

        editFaceBtn.addEventListener('click', () => {
          openFaceEditor(index);
        });

        idInput.addEventListener('input', (ev) => {
          npcs[index].id = ev.target.value.trim();
          persist();
          updateJsonOutput();
        });

        nameInput.addEventListener('input', (ev) => {
          npcs[index].name = ev.target.value;
          persist();
          renderNpcList();
        });

        skinInput.addEventListener('input', (ev) => {
          const value = ev.target.value;
          npcs[index].skinColor = value;
          persist();
          renderNpcList();
        });

        shirtInput.addEventListener('input', (ev) => {
          const value = ev.target.value;
          npcs[index].shirtColor = value;
          persist();
          renderNpcList();
        });

        pantsInput.addEventListener('input', (ev) => {
          const value = ev.target.value;
          npcs[index].pantsColor = value;
          persist();
          renderNpcList();
        });

        speedInput.addEventListener('input', (ev) => {
          const value = Number(ev.target.value);
          npcs[index].speed = Number.isFinite(value) ? Math.max(0.1, value) : npcs[index].speed;
          persist();
          updateJsonOutput();
        });

        duplicateBtn.addEventListener('click', () => {
          const copy = clone(npcs[index]);
          copy.id = generateNpcId();
          copy.name = `${copy.name} Copy`;
          npcs.splice(index + 1, 0, copy);
          persist();
          renderNpcList();
        });

        deleteBtn.addEventListener('click', () => {
          if (!confirm(`Remove ${npcs[index].name || 'this NPC'}?`)) return;
          npcs.splice(index, 1);
          persist();
          renderNpcList();
        });
      });

      updateNpcCount();
      updateJsonOutput();
    }

    function updateJsonOutput() {
      const exportPayload = npcs.map((npc) => {
        const payload = {
          id: npc.id.trim() || generateNpcId(),
          name: npc.name || 'Unnamed NPC',
          color: hexToColorArray(npc.skinColor),
          shirtColor: hexToColorArray(npc.shirtColor),
          pantsColor: hexToColorArray(npc.pantsColor),
          speed: npc.speed,
          schedule: clone(npc.schedule),
          metadata: clone(npc.metadata)
        };
        
        // Include face data if it exists
        if (npc.faceData) {
          payload.faceData = npc.faceData;
        }
        
        return payload;
      });

      jsonOutputEl.value = JSON.stringify(exportPayload, null, 2);
    }

    function loadFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return null;
        return parsed.map(normalizeStoredNpc);
      } catch (error) {
        console.warn('Failed to load NPC editor cache', error);
        return null;
      }
    }

    function addNpc(initial = {}) {
      npcs.push(normalizeDefinition(initial));
      persist();
      renderNpcList();
    }

    function resetToDefaults() {
      npcs = defaultNpcDefinitions.map(normalizeDefinition);
      persist();
      renderNpcList();
    }

    function clearAll() {
      npcs = [];
      persist();
      renderNpcList();
    }

    function copyJsonToClipboard() {
      navigator.clipboard.writeText(jsonOutputEl.value).then(() => {
        alert('NPC JSON copied to clipboard.');
      }).catch((error) => {
        console.warn('Clipboard error', error);
        alert('Unable to copy. Please copy manually.');
      });
    }

    function downloadJson() {
      const blob = new Blob([jsonOutputEl.value], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'npcs.json';
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    }

    function toggleImportPanel() {
      importPanel.classList.toggle('visible');
      if (!importPanel.classList.contains('visible')) {
        importInput.value = '';
      }
    }

    function applyImport() {
      const value = importInput.value.trim();
      if (!value) {
        alert('Paste JSON first.');
        return;
      }

      try {
        const parsed = JSON.parse(value);
        let entries = [];
        if (Array.isArray(parsed)) {
          entries = parsed;
        } else if (parsed && Array.isArray(parsed.npcs)) {
          entries = parsed.npcs;
        } else {
          throw new Error('Expected an array or an object with an "npcs" array.');
        }

        npcs = entries.map(normalizeDefinition);
        persist();
        renderNpcList();
        toggleImportPanel();
      } catch (error) {
        console.error('Import error', error);
        alert(`Unable to parse JSON: ${error.message}`);
      }
    }

    document.getElementById('addNpcBtn').addEventListener('click', () => addNpc());
    document.getElementById('resetDefaultsBtn').addEventListener('click', resetToDefaults);
    document.getElementById('clearAllBtn').addEventListener('click', () => {
      if (!confirm('Remove all NPCs from the editor?')) return;
      clearAll();
    });
    document.getElementById('copyJsonBtn').addEventListener('click', copyJsonToClipboard);
    document.getElementById('downloadJsonBtn').addEventListener('click', downloadJson);
    document.getElementById('toggleImportBtn').addEventListener('click', toggleImportPanel);
    document.getElementById('applyImportBtn').addEventListener('click', applyImport);
    document.getElementById('cancelImportBtn').addEventListener('click', toggleImportPanel);

    // ===== FACE EDITOR =====
    let currentEditingNpcIndex = null;
    let faceEditorState = {
      tool: 'draw',
      color: '#000000',
      brushSize: 1,
      imageData: null
    };

    const faceCanvas = document.getElementById('faceCanvas');
    const faceCtx = faceCanvas.getContext('2d');
    const facePreview = document.getElementById('facePreview');
    const facePreviewCtx = facePreview.getContext('2d');
    const faceModal = document.getElementById('faceEditorModal');

    // Disable image smoothing for pixelated look
    faceCtx.imageSmoothingEnabled = false;
    facePreviewCtx.imageSmoothingEnabled = false;

    function openFaceEditor(npcIndex) {
      currentEditingNpcIndex = npcIndex;
      const npc = npcs[npcIndex];
      
      // Load existing face data or create default
      if (npc.faceData) {
        loadFaceFromData(npc.faceData);
      } else {
        createDefaultFace(npc.skinColor);
      }
      
      updatePreview();
      faceModal.classList.add('active');
    }

    function closeFaceEditor() {
      faceModal.classList.remove('active');
      currentEditingNpcIndex = null;
    }

    function createDefaultFace(skinColor) {
      // Clear canvas with skin color
      faceCtx.fillStyle = skinColor;
      faceCtx.fillRect(0, 0, 512, 512);

      // Draw eyes (black rectangles)
      faceCtx.fillStyle = '#000000';
      faceCtx.fillRect(128, 160, 64, 64);  // Left eye
      faceCtx.fillRect(320, 160, 64, 64);  // Right eye

      // Draw nose (brown rectangle)
      faceCtx.fillStyle = '#8B4513';
      faceCtx.fillRect(224, 256, 64, 48);

      // Draw mouth (black line)
      faceCtx.fillStyle = '#000000';
      faceCtx.fillRect(160, 360, 192, 24);
    }

    function loadFaceFromData(dataUrl) {
      const img = new Image();
      img.onload = () => {
        faceCtx.drawImage(img, 0, 0, 512, 512);
        updatePreview();
      };
      img.src = dataUrl;
    }

    function updatePreview() {
      // Scale down to 128x128 for preview
      facePreviewCtx.drawImage(faceCanvas, 0, 0, 128, 128);
    }

    function saveFace() {
      if (currentEditingNpcIndex === null) return;
      
      // Save as data URL
      const dataUrl = faceCanvas.toDataURL();
      npcs[currentEditingNpcIndex].faceData = dataUrl;
      
      persist();
      updateJsonOutput();
      closeFaceEditor();
      
      console.log('Face saved for NPC:', npcs[currentEditingNpcIndex].name);
    }

    // Drawing on canvas
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    faceCanvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      const rect = faceCanvas.getBoundingClientRect();
      lastX = Math.floor((e.clientX - rect.left) * (512 / rect.width));
      lastY = Math.floor((e.clientY - rect.top) * (512 / rect.height));
      
      if (faceEditorState.tool === 'eyedropper') {
        pickColor(lastX, lastY);
        isDrawing = false;
      } else if (faceEditorState.tool === 'fill') {
        floodFill(lastX, lastY);
        isDrawing = false;
        updatePreview();
      } else {
        draw(lastX, lastY);
      }
    });

    faceCanvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;
      if (faceEditorState.tool === 'fill' || faceEditorState.tool === 'eyedropper') return;
      
      const rect = faceCanvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) * (512 / rect.width));
      const y = Math.floor((e.clientY - rect.top) * (512 / rect.height));
      
      drawLine(lastX, lastY, x, y);
      lastX = x;
      lastY = y;
    });

    faceCanvas.addEventListener('mouseup', () => {
      if (isDrawing) {
        isDrawing = false;
        updatePreview();
      }
    });

    faceCanvas.addEventListener('mouseleave', () => {
      if (isDrawing) {
        isDrawing = false;
        updatePreview();
      }
    });

    function draw(x, y) {
      const size = faceEditorState.brushSize;
      const halfSize = Math.floor(size / 2);
      
      if (faceEditorState.tool === 'erase') {
        // Get skin color from current NPC
        const skinColor = currentEditingNpcIndex !== null ? 
          npcs[currentEditingNpcIndex].skinColor : '#E6B380';
        faceCtx.fillStyle = skinColor;
      } else {
        faceCtx.fillStyle = faceEditorState.color;
      }
      
      faceCtx.fillRect(x - halfSize, y - halfSize, size, size);
    }

    function drawLine(x0, y0, x1, y1) {
      const dx = Math.abs(x1 - x0);
      const dy = Math.abs(y1 - y0);
      const sx = x0 < x1 ? 1 : -1;
      const sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;

      while (true) {
        draw(x0, y0);

        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) {
          err -= dy;
          x0 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y0 += sy;
        }
      }
    }

    function pickColor(x, y) {
      const pixel = faceCtx.getImageData(x, y, 1, 1).data;
      const hex = '#' + [pixel[0], pixel[1], pixel[2]]
        .map(x => x.toString(16).padStart(2, '0')).join('');
      faceEditorState.color = hex;
      
      // Update active color in palette
      document.querySelectorAll('.palette-color').forEach(el => el.classList.remove('active'));
      document.getElementById('customColorPicker').value = hex;
    }

    function floodFill(startX, startY) {
      const imageData = faceCtx.getImageData(0, 0, 512, 512);
      const pixels = imageData.data;
      const targetColor = getPixelColor(pixels, startX, startY);
      const fillColor = hexToRgb(faceEditorState.tool === 'erase' ? 
        npcs[currentEditingNpcIndex].skinColor : faceEditorState.color);
      
      if (colorsMatch(targetColor, fillColor)) return;
      
      const stack = [[startX, startY]];
      const visited = new Set();
      
      while (stack.length > 0) {
        const [x, y] = stack.pop();
        const key = `${x},${y}`;
        
        if (visited.has(key)) continue;
        if (x < 0 || x >= 512 || y < 0 || y >= 512) continue;
        
        const currentColor = getPixelColor(pixels, x, y);
        if (!colorsMatch(currentColor, targetColor)) continue;
        
        visited.add(key);
        setPixelColor(pixels, x, y, fillColor);
        
        stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
      }
      
      faceCtx.putImageData(imageData, 0, 0);
    }

    function getPixelColor(pixels, x, y) {
      const i = (y * 512 + x) * 4;
      return [pixels[i], pixels[i + 1], pixels[i + 2], pixels[i + 3]];
    }

    function setPixelColor(pixels, x, y, color) {
      const i = (y * 512 + x) * 4;
      pixels[i] = color[0];
      pixels[i + 1] = color[1];
      pixels[i + 2] = color[2];
      pixels[i + 3] = 255;
    }

    function colorsMatch(c1, c2) {
      return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2];
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ] : [0, 0, 0];
    }

    // Tool buttons
    document.querySelectorAll('.tool-button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        faceEditorState.tool = btn.dataset.tool;
      });
    });

    // Brush size buttons
    document.querySelectorAll('.brush-size').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.brush-size').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        faceEditorState.brushSize = parseInt(btn.dataset.size);
      });
    });

    // Color palette
    document.querySelectorAll('.palette-color').forEach(div => {
      div.addEventListener('click', () => {
        document.querySelectorAll('.palette-color').forEach(d => d.classList.remove('active'));
        div.classList.add('active');
        faceEditorState.color = div.dataset.color;
        document.getElementById('customColorPicker').value = div.dataset.color;
      });
    });

    // Custom color picker
    document.getElementById('customColorPicker').addEventListener('input', (e) => {
      faceEditorState.color = e.target.value;
      document.querySelectorAll('.palette-color').forEach(d => d.classList.remove('active'));
    });

    // Clear face
    document.getElementById('clearFaceBtn').addEventListener('click', () => {
      if (currentEditingNpcIndex !== null) {
        const skinColor = npcs[currentEditingNpcIndex].skinColor;
        faceCtx.fillStyle = skinColor;
        faceCtx.fillRect(0, 0, 512, 512);
        updatePreview();
      }
    });

    // Default face
    document.getElementById('defaultFaceBtn').addEventListener('click', () => {
      if (currentEditingNpcIndex !== null) {
        createDefaultFace(npcs[currentEditingNpcIndex].skinColor);
        updatePreview();
      }
    });

    // Modal controls
    document.getElementById('closeFaceEditor').addEventListener('click', closeFaceEditor);
    document.getElementById('cancelFaceBtn').addEventListener('click', closeFaceEditor);
    document.getElementById('saveFaceBtn').addEventListener('click', saveFace);

    // Close modal on outside click
    faceModal.addEventListener('click', (e) => {
      if (e.target === faceModal) {
        closeFaceEditor();
      }
    });

    function init() {
      const cached = loadFromStorage();
      if (cached && cached.length) {
        npcs = cached;
      } else {
        npcs = defaultNpcDefinitions.map(normalizeDefinition);
      }
      updateNpcCount();
      renderNpcList();
    }

    init();
  </script>
</body>
</html>
