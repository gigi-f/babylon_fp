<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon FP - Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #4CAF50;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: inline-block;
            width: 120px;
            color: #aaa;
        }
        
        .control-group input,
        .control-group select {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .tool-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .tool-btn {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }
        
        .tool-btn:hover {
            border-color: #4CAF50;
            background: #444;
        }
        
        .tool-btn.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .canvas-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: auto;
        }
        
        #mapCanvas {
            background: #1a1a1a;
            border: 2px solid #444;
            cursor: crosshair;
        }
        
        .export-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }
        
        .export-section h2 {
            color: #4CAF50;
            margin-bottom: 15px;
        }
        
        #jsonOutput {
            width: 100%;
            height: 300px;
            background: #1a1a1a;
            color: #4CAF50;
            border: 1px solid #444;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .action-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            background: #4CAF50;
            color: #000;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        .action-btn:hover {
            background: #45a049;
        }
        
        .legend {
            background: #2a2a2a;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        .legend h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }
        
        .legend-items {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .legend-item:hover {
            background-color: #333;
        }
        
        .legend-item.active {
            background-color: #4CAF50;
        }
        
        .legend-color {
            width: 30px;
            height: 30px;
            border: 1px solid #fff;
        }
        
        .minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: #1a1a1a;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }
        
        .minimap.visible {
            display: block;
        }
        
        .minimap canvas {
            width: 100%;
            height: 100%;
        }
        
        /* NPC Type Selection Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-content {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 12px;
            border: 2px solid #4CAF50;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .modal-content h3 {
            margin: 0 0 20px 0;
            color: #4CAF50;
            font-size: 20px;
            text-align: center;
        }
        
        .npc-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .npc-type-btn {
            padding: 20px;
            background: #1a1a1a;
            border: 2px solid #444;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .npc-type-btn:hover {
            background: #333;
            border-color: #4CAF50;
            transform: translateY(-2px);
        }
        
        .npc-type-btn .emoji {
            font-size: 32px;
        }
        
        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        .modal-btn.cancel {
            background: #666;
            color: #fff;
        }
        
        .modal-btn.cancel:hover {
            background: #777;
        }
        
        .modal-btn.refresh {
            background: #2196F3;
            color: #fff;
        }
        
        .modal-btn.refresh:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <!-- NPC Type Selection Modal -->
    <div id="npc-type-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>üë§ Select NPC Type</h3>
            <div id="npc-type-grid" class="npc-type-grid">
                <button class="npc-type-btn" data-npc-type="baker">
                    <span class="emoji">ü•ñ</span>
                    <span>Baker</span>
                </button>
                <button class="npc-type-btn" data-npc-type="guard">
                    <span class="emoji">üõ°Ô∏è</span>
                    <span>Guard</span>
                </button>
                <button class="npc-type-btn" data-npc-type="thief">
                    <span class="emoji">ü™ô</span>
                    <span>Thief</span>
                </button>
            </div>
            <div class="modal-actions">
                <button class="modal-btn refresh" onclick="refreshNpcList()">üîÑ Refresh NPCs</button>
                <button class="modal-btn cancel" onclick="closeNpcTypeModal()">Cancel</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h1>üèóÔ∏è Babylon FP Map Editor</h1>
        
        <div style="background: #1f1f1f; padding: 12px 16px; border-radius: 6px; border: 1px solid #333; margin-bottom: 16px; color: #b5b5b5; font-size: 14px;">
            <strong style="color: #66bb6a;">üí° Tip:</strong> The NPC list automatically syncs with the NPC Editor. Create or edit NPCs in <code style="background: #2a2a2a; padding: 2px 6px; border-radius: 3px;">npc-editor.html</code>, then click <strong style="color: #4CAF50;">üîÑ Refresh</strong> to update the list here.
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Grid Size:</label>
                <input type="number" id="gridSize" value="100" min="10" max="200">
                <span id="worldInfo" style="color: #666; margin-left: 10px;"></span>
            </div>
            
            <div class="control-group">
                <label>Zoom:</label>
                <input type="range" id="zoom" min="1" max="5" step="0.5" value="1">
                <span id="zoomLevel" style="color: #666; margin-left: 10px;">100%</span>
                <span style="color: #666; margin-left: 10px;">Scroll wheel to zoom</span>
                <button id="resetView" style="margin-left: 15px; padding: 5px 10px; background: #555; color: white; border: 1px solid #666; border-radius: 4px; cursor: pointer;">Reset View</button>
            </div>
            
            <div class="control-group">
                <label>Rotation:</label>
                <select id="rotation">
                    <option value="0">0¬∞ (Horizontal)</option>
                    <option value="90">90¬∞ (Vertical)</option>
                    <option value="180">180¬∞</option>
                    <option value="270">270¬∞</option>
                </select>
                <span style="color: #666; margin-left: 10px;">Press 'R' to rotate</span>
            </div>
            
            <!-- Schedule Editor - Only shown when NPC is selected -->
            <div id="schedule-editor" style="display: none; margin-bottom: 15px; padding: 15px; background: #2a2a2a; border-radius: 8px; border: 2px solid #4CAF50;">
                <h3 style="margin: 0 0 10px 0; color: #4CAF50; font-size: 16px;">üìÖ Schedule Editor</h3>
                <div id="selected-npc-info" style="margin-bottom: 10px; padding: 8px; background: #1a1a1a; border-radius: 4px; color: #aaa; font-size: 13px;">
                    <strong>Editing:</strong> <span id="selected-npc-name">None</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <label for="waypoint-time" style="display: block; margin-bottom: 5px; font-weight: bold;">Waypoint Time:</label>
                    <input type="time" id="waypoint-time" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: #fff; border-radius: 4px;">
                    <small style="color: #999; display: block; margin-top: 5px;">
                        Click on the map to place a schedule waypoint at this time
                    </small>
                </div>
                <div style="margin-bottom: 10px;">
                    <strong>Current Schedule:</strong>
                    <div id="schedule-list" style="max-height: 200px; overflow-y: auto; margin-top: 5px; padding: 8px; background: #1a1a1a; border-radius: 4px;">
                        <em style="color: #999;">No waypoints yet.</em>
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button id="save-schedule" style="flex: 1; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                        ‚úì Save & Close
                    </button>
                    <button id="clear-schedule" style="flex: 1; padding: 10px; background: #d32f2f; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        üóëÔ∏è Clear Schedule
                    </button>
                </div>
            </div>
            
            <div class="control-group">
                <label>Brush Tool:</label>
            </div>
            <div class="tool-buttons">
                <button class="tool-btn" data-tool="select">üëÜ Select</button>
                <button class="tool-btn active" data-tool="wall">üß± Wall</button>
                <button class="tool-btn" data-tool="floor">‚¨ú Floor</button>
                <button class="tool-btn" data-tool="door">üö™ Door</button>
                <button class="tool-btn" data-tool="window">ü™ü Window</button>
                <button class="tool-btn" data-tool="npc-spawn">üë§ NPC Spawn</button>
                <button class="tool-btn" data-tool="player-spawn">üéÆ Player Spawn</button>
                <button class="tool-btn" data-tool="erase">‚ùå Erase</button>
            </div>
        </div>
        
        <div class="legend">
            <h3>Legend</h3>
            <div class="legend-items">
                <div class="legend-item" data-tool="wall">
                    <div class="legend-color" style="background: #666;"></div>
                    <span>Wall</span>
                </div>
                <div class="legend-item" data-tool="floor">
                    <div class="legend-color" style="background: #ddd;"></div>
                    <span>Floor</span>
                </div>
                <div class="legend-item" data-tool="door">
                    <div class="legend-color" style="background: #8B4513;"></div>
                    <span>Door</span>
                </div>
                <div class="legend-item" data-tool="window">
                    <div class="legend-color" style="background: #87CEEB;"></div>
                    <span>Window</span>
                </div>
                <div class="legend-item" data-tool="npc-spawn">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>NPC Spawn</span>
                </div>
                <div class="legend-item" data-tool="player-spawn">
                    <div class="legend-color" style="background: #FF4444;"></div>
                    <span>Player Spawn</span>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="mapCanvas"></canvas>
        </div>
        
        <!-- Minimap (shown when zoomed) -->
        <div class="minimap" id="minimap">
            <canvas id="minimapCanvas" width="200" height="200"></canvas>
        </div>
        
        <div class="export-section">
            <h2>Export Map Data</h2>
            <textarea id="jsonOutput" readonly></textarea>
            <div class="action-buttons">
                <button class="action-btn" onclick="importJSON()">üì• Import JSON</button>
                <button class="action-btn" onclick="copyToClipboard()">üìã Copy JSON</button>
                <button class="action-btn" onclick="downloadJSON()">üíæ Download JSON</button>
                <button class="action-btn" onclick="clearMap()">üóëÔ∏è Clear Map</button>
            </div>
        </div>
    </div>
    
    <!-- Hidden file input for import -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="handleFileImport(event)">

    <script>
        // Shared world constants - must match src/config/worldConstants.ts
        const GRID_CELL_SIZE = 1; // Each grid cell = 1 unit in 3D world space
        const WALL_WIDTH = 1.0; // Width of walls (1 cell wide)
        const DOOR_WIDTH = 2.0; // Width of doors (2 cells wide for player to fit)
        const WINDOW_WIDTH = 1.0; // Width of windows (1 cell wide)
        
        // Tile size in grid cells (how many cells each tile type occupies)
        const TILE_GRID_SIZES = {
            'wall': 1,
            'floor': 1,
            'door': 2,  // Doors occupy 2 grid cells
            'window': 1,
            'npc-spawn': 1,
            'player-spawn': 1,
            'erase': 1
        };
        
        // Map editor configuration
        const CELL_SIZE = GRID_CELL_SIZE; // Alias for backwards compatibility
        const NPC_STORAGE_KEY = 'babylon-fp-npc-editor-v1'; // Same key as NPC editor
        let gridSize = 100; // 100x100 grid
        let currentTool = 'select'; // Start with select tool
        let currentRotation = 0; // 0, 90, 180, 270
        let currentNpcType = 'baker'; // Default NPC type
        let cursorGridX = -1;
        let cursorGridY = -1;
        
        // Schedule editing state
        let scheduleMode = false;
        let selectedNpcSpawn = null; // The NPC spawn tile we're editing schedule for
        let npcSchedules = new Map(); // Map of npc spawn tile ID -> array of waypoints
        
        // Zoom and Pan
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;
        
        // Click and drag painting
        let isPainting = false;
        let lastPaintedGridX = -1;
        let lastPaintedGridY = -1;
        
        // Map data
        const mapData = {
            metadata: {
                gridSize: 100,
                cellSize: 1,
                worldSize: 100,
                version: "1.0.0"
            },
            tiles: []
        };
        
        // Canvas setup
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        
        // Colors for different tile types
        const tileColors = {
            wall: '#666',
            floor: '#ddd',
            door: '#8B4513',
            window: '#87CEEB',
            'npc-spawn': '#FFD700',
            'player-spawn': '#FF4444'
        };
        
        // NPC-specific colors (will be dynamically updated from localStorage)
        const npcColors = {
            baker: '#D2691E',    // Tan/brown for baker
            guard: '#4169E1',    // Royal blue for guard
            thief: '#8B8B8B'    // Gray for thief
        };
        
        // Load NPCs from NPC editor's localStorage
        function loadNpcsFromStorage() {
            try {
                const raw = localStorage.getItem(NPC_STORAGE_KEY);
                if (!raw) {
                    console.log('No NPCs found in localStorage, using defaults');
                    return null;
                }
                const npcs = JSON.parse(raw);
                if (!Array.isArray(npcs)) {
                    console.warn('Invalid NPC data format');
                    return null;
                }
                return npcs;
            } catch (error) {
                console.error('Error loading NPCs from localStorage:', error);
                return null;
            }
        }
        
        // Convert RGB array (0-1) to hex color
        function colorArrayToHex(arr) {
            if (!arr || arr.length !== 3) return '#FFD700'; // Default gold
            const r = Math.round(arr[0] * 255);
            const g = Math.round(arr[1] * 255);
            const b = Math.round(arr[2] * 255);
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }
        
        // Populate NPC dropdown and colors from localStorage
        function populateNpcList() {
            const npcs = loadNpcsFromStorage();
            const select = document.getElementById('npc-type-select');
            
            if (!npcs || npcs.length === 0) {
                console.log('Using default NPC list');
                return;
            }
            
            // Clear existing options
            select.innerHTML = '';
            
            // Add each NPC from storage
            npcs.forEach(npc => {
                const option = document.createElement('option');
                option.value = npc.id;
                
                // Try to add an emoji based on NPC type/name
                const emoji = getEmojiForNpc(npc);
                option.textContent = `${emoji} ${npc.name}`;
                
                select.appendChild(option);
                
                // Update color mapping - use shirt color if available, otherwise skin color
                const color = npc.shirtColor || npc.color;
                npcColors[npc.id] = colorArrayToHex(color);
            });
            
            // Set current NPC type to first option
            if (npcs.length > 0) {
                currentNpcType = npcs[0].id;
            }
            
            console.log(`Loaded ${npcs.length} NPCs from NPC editor`);
        }
        
        // Get appropriate emoji for NPC based on name/id
        function getEmojiForNpc(npc) {
            const name = (npc.name || npc.id).toLowerCase();
            if (name.includes('baker')) return 'ü•ñ';
            if (name.includes('guard')) return 'üõ°Ô∏è';
            if (name.includes('thief')) return 'ü™ô';
            if (name.includes('merchant')) return 'üí∞';
            if (name.includes('farmer')) return 'üåæ';
            if (name.includes('blacksmith')) return 'üî®';
            if (name.includes('priest') || name.includes('cleric')) return '‚õ™';
            if (name.includes('noble')) return 'üëë';
            if (name.includes('child')) return 'üë∂';
            return 'üë§'; // Default person emoji
        }
        
        // Get color for a tile (handles NPC-specific colors)
        function getTileColor(tile) {
            if (tile.type === 'npc-spawn' && tile.npcType) {
                return npcColors[tile.npcType] || tileColors['npc-spawn'];
            }
            return tileColors[tile.type] || '#fff';
        }
        
        // NPC Type Modal Functions
        function openNpcTypeModal() {
            document.getElementById('npc-type-modal').classList.add('active');
        }
        
        function closeNpcTypeModal() {
            document.getElementById('npc-type-modal').classList.remove('active');
        }
        
        // Schedule Editor Functions
        function openScheduleEditor(npcTile) {
            selectedNpcSpawn = npcTile;
            scheduleMode = true;
            
            // Update the displayed NPC info
            const npcName = npcTile.npcType ? npcTile.npcType.charAt(0).toUpperCase() + npcTile.npcType.slice(1) : 'Unknown';
            const npcEmoji = npcColors[npcTile.npcType]?.emoji || 'üë§';
            document.getElementById('selected-npc-name').textContent = `${npcEmoji} ${npcName} at (${npcTile.gridX}, ${npcTile.gridY})`;
            
            // Show the schedule editor
            document.getElementById('schedule-editor').style.display = 'block';
            
            // Ensure we have a schedule for this NPC
            const scheduleKey = getNpcScheduleKey(npcTile);
            if (!npcSchedules.has(scheduleKey)) {
                npcSchedules.set(scheduleKey, []);
            }
            
            updateScheduleList();
        }
        
        function closeScheduleEditor() {
            selectedNpcSpawn = null;
            scheduleMode = false;
            document.getElementById('schedule-editor').style.display = 'none';
            drawGrid(); // Redraw to remove waypoint markers
        }
        
        // Refresh NPC list (callable from UI button)
        function refreshNpcList() {
            populateNpcList();
            drawGrid(); // Redraw grid to update colors
            console.log('NPC list refreshed from NPC editor');
        }
        
        // Initialize
        function init() {
            // Load NPCs from NPC editor first
            populateNpcList();
            
            // Add default player spawn if map is empty
            if (mapData.tiles.length === 0) {
                const centerGridX = Math.floor(gridSize / 2);
                const centerGridY = Math.floor(gridSize / 2);
                mapData.tiles.push({
                    type: 'player-spawn',
                    gridX: centerGridX,
                    gridY: centerGridY,
                    worldX: 0,
                    worldZ: 0,
                    rotation: 0
                });
            }
            
            updateGridSize();
            drawGrid();
            updateJSON();
            
            // Set default time for schedule waypoints
            document.getElementById('waypoint-time').value = '00:00';
            
            // Set initial active state for select tool (new default)
            const initialBtn = document.querySelector('.tool-btn[data-tool="select"]');
            if (initialBtn) initialBtn.classList.add('active');
            
            // Set initial cursor to pointer for select tool
            canvas.style.cursor = 'pointer';
            
            // Event listeners
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', () => {
                cursorGridX = -1;
                cursorGridY = -1;
                isPanning = false;
                isPainting = false;
                lastPaintedGridX = -1;
                lastPaintedGridY = -1;
                drawGrid();
            });
            
            // Pan with middle mouse button only
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 1) { // Middle mouse button only
                    e.preventDefault();
                    isPanning = true;
                    isPainting = false; // Cancel painting if middle mouse is pressed
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 1) {
                    isPanning = false;
                    // Restore cursor based on current tool
                    if (currentTool === 'select') {
                        canvas.style.cursor = 'pointer';
                    } else {
                        canvas.style.cursor = 'crosshair';
                    }
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    e.preventDefault();
                    const dx = e.clientX - lastPanX;
                    const dy = e.clientY - lastPanY;
                    
                    // Apply pan with bounds checking
                    const newPanX = panX + dx;
                    const newPanY = panY + dy;
                    
                    // Calculate bounds - allow panning up to half a canvas width/height beyond the grid edges
                    const maxPan = canvas.width * 0.5;
                    const minPan = -(canvas.width * zoomLevel) + maxPan;
                    
                    // Clamp pan values to bounds
                    panX = Math.max(minPan, Math.min(maxPan, newPanX));
                    panY = Math.max(minPan, Math.min(maxPan, newPanY));
                    
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    drawGrid();
                    return; // Don't process hover while panning
                }
                
                // Handle normal hover
                handleCanvasHover(e);
                
                // Handle painting while dragging
                if (isPainting) {
                    handleCanvasPaint(e);
                }
            });
            
            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                zoomLevel = Math.max(1, Math.min(5, zoomLevel + delta));
                document.getElementById('zoom').value = zoomLevel;
                updateZoomDisplay();
                drawGrid();
            }, { passive: false });
            
            // Shared function to select a tool
            function selectTool(tool) {
                // Special handling for NPC spawn - show modal instead
                if (tool === 'npc-spawn') {
                    openNpcTypeModal();
                    return;
                }
                
                currentTool = tool;
                
                // Close schedule editor if switching away from select tool
                if (tool !== 'select') {
                    closeScheduleEditor();
                }
                
                // Update button states
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                const activeBtn = document.querySelector(`.tool-btn[data-tool="${tool}"]`);
                if (activeBtn) activeBtn.classList.add('active');
                
                // Update canvas cursor based on tool
                if (tool === 'select') {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
                
                // Update legend item states
                document.querySelectorAll('.legend-item').forEach(l => l.classList.remove('active'));
                const activeLegend = document.querySelector(`.legend-item[data-tool="${tool}"]`);
                if (activeLegend) activeLegend.classList.add('active');
                
                drawGrid(); // Redraw to show new preview
            }
            
            // Tool button click handlers
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    selectTool(e.target.dataset.tool);
                });
            });
            
            // Legend item click handlers
            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const tool = e.currentTarget.dataset.tool;
                    selectTool(tool);
                });
            });
            
            document.getElementById('gridSize').addEventListener('change', (e) => {
                gridSize = parseInt(e.target.value);
                updateGridSize();
            });
            
            document.getElementById('zoom').addEventListener('input', (e) => {
                zoomLevel = parseFloat(e.target.value);
                updateZoomDisplay();
                drawGrid();
            });
            
            document.getElementById('resetView').addEventListener('click', () => {
                zoomLevel = 1;
                panX = 0;
                panY = 0;
                document.getElementById('zoom').value = '1';
                updateZoomDisplay();
                drawGrid();
            });
            
            document.getElementById('rotation').addEventListener('change', (e) => {
                currentRotation = parseInt(e.target.value);
                drawGrid(); // Redraw to show new orientation
            });
            
            // NPC Type Modal event listeners
            document.querySelectorAll('.npc-type-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const npcType = e.currentTarget.dataset.npcType;
                    currentNpcType = npcType;
                    closeNpcTypeModal();
                    
                    // Manually set the npc-spawn tool active without triggering modal
                    currentTool = 'npc-spawn';
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    const npcBtn = document.querySelector('.tool-btn[data-tool="npc-spawn"]');
                    if (npcBtn) npcBtn.classList.add('active');
                    canvas.style.cursor = 'crosshair';
                    
                    // Update legend items
                    document.querySelectorAll('.legend-item').forEach(l => l.classList.remove('active'));
                    const activeLegend = document.querySelector('.legend-item[data-tool="npc-spawn"]');
                    if (activeLegend) activeLegend.classList.add('active');
                    
                    drawGrid();
                });
            });
            
            // Clear schedule button
            document.getElementById('clear-schedule').addEventListener('click', () => {
                if (selectedNpcSpawn && confirm('Clear all waypoints for this NPC?')) {
                    const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
                    npcSchedules.delete(scheduleKey);
                    updateScheduleList();
                    drawGrid();
                    updateJSON(); // Update JSON to reflect cleared schedule
                }
            });
            
            // Save schedule button
            document.getElementById('save-schedule').addEventListener('click', () => {
                // Close schedule editor using new helper function
                closeScheduleEditor();
                
                // Switch back to select tool
                selectTool('select');
                
                console.log('Schedule saved and editor closed');
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'r' || e.key === 'R') {
                    currentRotation = (currentRotation + 90) % 360;
                    document.getElementById('rotation').value = currentRotation;
                    drawGrid(); // Redraw to show new orientation
                }
            });
        }
        
        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = `${Math.round(zoomLevel * 100)}%`;
            
            // Show/hide minimap based on zoom level
            if (zoomLevel > 1.5) {
                minimap.classList.add('visible');
                drawMinimap();
            } else {
                minimap.classList.remove('visible');
            }
        }
        
        function updateGridSize() {
            const size = gridSize * 10; // 10 pixels per cell for visibility
            canvas.width = size;
            canvas.height = size;
            mapData.metadata.gridSize = gridSize;
            mapData.metadata.worldSize = gridSize * CELL_SIZE;
            
            // Reset pan when grid size changes
            panX = 0;
            panY = 0;
            
            // Update world info display
            const worldInfo = document.getElementById('worldInfo');
            worldInfo.textContent = `(World: ${mapData.metadata.worldSize}x${mapData.metadata.worldSize}, Cell size: ${CELL_SIZE} units)`;
            
            drawGrid();
        }
        
        function drawGrid() {
            const cellPixels = canvas.width / gridSize; // Base cell size without zoom
            
            // Save context state
            ctx.save();
            
            // Apply zoom and pan transforms
            ctx.translate(panX, panY);
            ctx.scale(zoomLevel, zoomLevel);
            
            // Clear canvas (must clear before transform)
            ctx.fillStyle = '#1a1a1a';
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for clear
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.setTransform(zoomLevel, 0, 0, zoomLevel, panX, panY); // Re-apply transform
            
            // Draw tiles
            mapData.tiles.forEach(tile => {
                const x = tile.gridX * cellPixels;
                const y = tile.gridY * cellPixels;
                drawTileWithOrientation(tile, x, y, cellPixels);
            });
            
            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= gridSize; i++) {
                const pos = i * cellPixels;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(canvas.width, pos);
                ctx.stroke();
            }
            
            // Draw coordinate labels every 10 cells
            ctx.fillStyle = '#666';
            ctx.font = '10px Courier New';
            for (let i = 0; i <= gridSize; i += 10) {
                const pos = i * cellPixels;
                ctx.fillText(i.toString(), pos + 2, 10);
                ctx.fillText(i.toString(), 2, pos + 10);
            }
            
            // Draw cursor preview
            if (cursorGridX >= 0 && cursorGridY >= 0 && cursorGridX < gridSize && cursorGridY < gridSize) {
                drawCursorPreview(cursorGridX, cursorGridY, cellPixels);
            }
            
            // Draw schedule waypoints and paths
            if (scheduleMode && selectedNpcSpawn) {
                drawScheduleWaypoints(cellPixels);
            }
            
            // Restore context state
            ctx.restore();
            
            // Draw minimap if zoomed in
            if (zoomLevel > 1.5) {
                drawMinimap();
            }
        }
        
        function drawScheduleWaypoints(cellPixels) {
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            
            if (waypoints.length === 0) return;
            
            // Draw connecting lines first (so they're behind the waypoint dots)
            ctx.strokeStyle = '#ff3333';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            for (let i = 0; i < waypoints.length - 1; i++) {
                const wp1 = waypoints[i];
                const wp2 = waypoints[i + 1];
                
                const x1 = wp1.gridX * cellPixels + cellPixels / 2;
                const y1 = wp1.gridY * cellPixels + cellPixels / 2;
                const x2 = wp2.gridX * cellPixels + cellPixels / 2;
                const y2 = wp2.gridY * cellPixels + cellPixels / 2;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Draw loop back to start
            if (waypoints.length > 1) {
                const wpLast = waypoints[waypoints.length - 1];
                const wpFirst = waypoints[0];
                
                const x1 = wpLast.gridX * cellPixels + cellPixels / 2;
                const y1 = wpLast.gridY * cellPixels + cellPixels / 2;
                const x2 = wpFirst.gridX * cellPixels + cellPixels / 2;
                const y2 = wpFirst.gridY * cellPixels + cellPixels / 2;
                
                ctx.strokeStyle = '#ff6666';
                ctx.setLineDash([2, 8]);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // Draw waypoint tiles
            waypoints.forEach((wp, idx) => {
                const x = wp.gridX * cellPixels;
                const y = wp.gridY * cellPixels;
                
                // Red tile
                ctx.fillStyle = '#ff3333';
                ctx.fillRect(x, y, cellPixels, cellPixels);
                
                // White border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, cellPixels, cellPixels);
                
                // Time label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(wp.timeString, x + cellPixels / 2, y + cellPixels / 2);
                
                // Waypoint number
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`#${idx + 1}`, x + 2, y + 2);
            });
        }
        
        function drawCursorPreview(gridX, gridY, cellPixels) {
            const x = gridX * cellPixels;
            const y = gridY * cellPixels;
            
            // In schedule mode, show red preview
            if (scheduleMode) {
                ctx.fillStyle = '#ff3333';
                ctx.globalAlpha = 0.7;
                ctx.fillRect(x, y, cellPixels, cellPixels);
                ctx.globalAlpha = 1.0;
                
                // Show time label
                const timeInput = document.getElementById('waypoint-time');
                if (timeInput.value) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(timeInput.value, x + cellPixels / 2, y + cellPixels / 2);
                }
                return;
            }
            
            // Don't show cursor preview for select tool
            if (currentTool === 'select') {
                return;
            }
            
            if (currentTool === 'erase') {
                // Red X for erase
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + cellPixels, y + cellPixels);
                ctx.moveTo(x + cellPixels, y);
                ctx.lineTo(x, y + cellPixels);
                ctx.stroke();
                return;
            }
            
            // Get tile size for this tool
            const tileGridSize = TILE_GRID_SIZES[currentTool] || 1;
            
            // Draw semi-transparent preview of the tile
            // Use NPC-specific color if placing an NPC spawn
            if (currentTool === 'npc-spawn') {
                ctx.fillStyle = npcColors[currentNpcType] || tileColors[currentTool] || '#fff';
            } else {
                ctx.fillStyle = tileColors[currentTool] || '#fff';
            }
            ctx.globalAlpha = 0.5;
            
            // For 2-cell tiles, draw based on rotation
            if (tileGridSize === 2) {
                if (currentRotation === 0 || currentRotation === 180) {
                    // Horizontal span (2 cells wide along X)
                    ctx.fillRect(x, y, cellPixels * 2, cellPixels);
                } else {
                    // Vertical span (2 cells tall along Y)
                    ctx.fillRect(x, y, cellPixels, cellPixels * 2);
                }
            } else {
                // Single cell
                ctx.fillRect(x, y, cellPixels, cellPixels);
            }
            
            ctx.globalAlpha = 1.0;
            
            // Draw orientation indicator for rotatable items
            if (currentTool === 'wall' || currentTool === 'door' || currentTool === 'window' ||
                currentTool === 'npc-spawn' || currentTool === 'player-spawn') {
                // Use currentRotation for all rotatable items including spawns
                const width = (tileGridSize === 2 && (currentRotation === 0 || currentRotation === 180)) ? cellPixels * 2 : cellPixels;
                const height = (tileGridSize === 2 && (currentRotation === 90 || currentRotation === 270)) ? cellPixels * 2 : cellPixels;
                drawOrientationIndicator(x, y, width, height, currentRotation);
            }
        }
        
        function drawOrientationIndicator(x, y, width, height, rotation) {
            // Bright green line on the "front" edge
            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            
            // Draw line based on rotation
            // 0¬∞ = front faces down (south), line at bottom
            // 90¬∞ = front faces left (west), line at left
            // 180¬∞ = front faces up (north), line at top
            // 270¬∞ = front faces right (east), line at right
            
            switch(rotation) {
                case 0: // Bottom edge (default/south)
                    ctx.moveTo(x, y + height);
                    ctx.lineTo(x + width, y + height);
                    // Draw arrow
                    ctx.moveTo(centerX, y + height);
                    ctx.lineTo(centerX - width/6, y + height - height/4);
                    ctx.moveTo(centerX, y + height);
                    ctx.lineTo(centerX + width/6, y + height - height/4);
                    break;
                case 90: // Left edge (west)
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + height);
                    // Draw arrow
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x + width/4, centerY - height/6);
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x + width/4, centerY + height/6);
                    break;
                case 180: // Top edge (north)
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + width, y);
                    // Draw arrow
                    ctx.moveTo(centerX, y);
                    ctx.lineTo(centerX - width/6, y + height/4);
                    ctx.moveTo(centerX, y);
                    ctx.lineTo(centerX + width/6, y + height/4);
                    break;
                case 270: // Right edge (east)
                    ctx.moveTo(x + width, y);
                    ctx.lineTo(x + width, y + height);
                    // Draw arrow
                    ctx.moveTo(x + width, centerY);
                    ctx.lineTo(x + width - width/4, centerY - height/6);
                    ctx.moveTo(x + width, centerY);
                    ctx.lineTo(x + width - width/4, centerY + height/6);
                    break;
            }
            
            ctx.stroke();
        }
        
        function drawTileWithOrientation(tile, x, y, cellPixels) {
            // Get tile size
            const tileGridSize = TILE_GRID_SIZES[tile.type] || 1;
            
            // Calculate tile dimensions based on size and rotation
            let tileWidth = cellPixels;
            let tileHeight = cellPixels;
            
            if (tileGridSize === 2 && tile.rotation !== undefined) {
                if (tile.rotation === 0 || tile.rotation === 180) {
                    tileWidth = cellPixels * 2;  // Horizontal
                } else {
                    tileHeight = cellPixels * 2;  // Vertical
                }
            }
            
            // Draw the base tile
            ctx.fillStyle = getTileColor(tile);
            ctx.fillRect(x, y, tileWidth, tileHeight);
            
            // Draw orientation if tile has rotation or is a spawn (which should always have rotation)
            const isRotatable = tile.type === 'wall' || tile.type === 'door' || tile.type === 'window' ||
                               tile.type === 'npc-spawn' || tile.type === 'player-spawn';
            
            if (isRotatable && tile.rotation !== undefined) {
                // Use helper function to draw orientation indicator
                drawOrientationIndicator(x, y, tileWidth, tileHeight, tile.rotation);
            }
        }
        
        function drawMinimap() {
            // Clear minimap
            minimapCtx.fillStyle = '#1a1a1a';
            minimapCtx.fillRect(0, 0, 200, 200);
            
            // Scale to fit entire grid
            const scale = 200 / (gridSize * 10);
            minimapCtx.save();
            minimapCtx.scale(scale, scale);
            
            // Draw all tiles
            const cellPixels = (gridSize * 10) / gridSize;
            mapData.tiles.forEach(tile => {
                const x = tile.gridX * cellPixels;
                const y = tile.gridY * cellPixels;
                minimapCtx.fillStyle = getTileColor(tile);
                minimapCtx.fillRect(x, y, cellPixels, cellPixels);
            });
            
            minimapCtx.restore();
            
            // Draw viewport rectangle
            const viewportWidth = (canvas.width / zoomLevel) * scale;
            const viewportHeight = (canvas.height / zoomLevel) * scale;
            const viewportX = (-panX / zoomLevel) * scale;
            const viewportY = (-panY / zoomLevel) * scale;
            
            minimapCtx.strokeStyle = '#4CAF50';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(viewportX, viewportY, viewportWidth, viewportHeight);
        }
        
        function handleCanvasMouseDown(e) {
            // Only start painting on left mouse button (button 0)
            if (e.button !== 0) return;
            if (isPanning) return;
            
            // Check if we can paint with current tool
            const paintableTools = ['wall', 'floor', 'window', 'erase'];
            if (paintableTools.includes(currentTool)) {
                isPainting = true;
                lastPaintedGridX = -1;
                lastPaintedGridY = -1;
                // The actual painting will happen in handleCanvasPaint via mousemove
                // or in handleCanvasClick if it's just a click without drag
            }
        }
        
        function handleCanvasMouseUp(e) {
            if (e.button !== 0) return;
            isPainting = false;
            lastPaintedGridX = -1;
            lastPaintedGridY = -1;
        }
        
        function handleCanvasPaint(e) {
            if (!isPainting) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert screen coordinates to grid coordinates accounting for zoom and pan
            const cellPixels = canvas.width / gridSize;
            const gridX = Math.floor((x - panX) / zoomLevel / cellPixels);
            const gridY = Math.floor((y - panY) / zoomLevel / cellPixels);
            
            // Only paint if we've moved to a new grid cell
            if (gridX === lastPaintedGridX && gridY === lastPaintedGridY) {
                return;
            }
            
            lastPaintedGridX = gridX;
            lastPaintedGridY = gridY;
            
            // Validate grid bounds
            if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) {
                return;
            }
            
            // Place the tile
            placeTile(gridX, gridY, currentTool);
            
            drawGrid();
            updateJSON();
        }
        
        function placeTile(gridX, gridY, tool) {
            if (tool === 'erase') {
                // Remove tile at this position
                mapData.tiles = mapData.tiles.filter(t => !(t.gridX === gridX && t.gridY === gridY));
                return;
            }
            
            // Get tile size for this tool
            const tileGridSize = TILE_GRID_SIZES[tool] || 1;
            
            // Remove existing tiles at this position
            mapData.tiles = mapData.tiles.filter(t => !(t.gridX === gridX && t.gridY === gridY));
            
            // Calculate world position
            let worldX, worldZ;
            if (tileGridSize === 2) {
                // For 2-cell tiles, position at the center between two cells
                if (currentRotation === 0 || currentRotation === 180) {
                    worldX = (gridX - gridSize / 2) * CELL_SIZE + CELL_SIZE / 2;
                    worldZ = (gridY - gridSize / 2) * CELL_SIZE;
                } else {
                    worldX = (gridX - gridSize / 2) * CELL_SIZE;
                    worldZ = (gridY - gridSize / 2) * CELL_SIZE + CELL_SIZE / 2;
                }
            } else {
                worldX = (gridX - gridSize / 2) * CELL_SIZE;
                worldZ = (gridY - gridSize / 2) * CELL_SIZE;
            }
            
            const newTile = {
                type: tool,
                gridX: gridX,
                gridY: gridY,
                worldX: worldX,
                worldZ: worldZ
            };
            
            // Add rotation for rotatable tiles
            if (tool === 'wall' || tool === 'door' || tool === 'window') {
                newTile.rotation = currentRotation;
            }
            
            mapData.tiles.push(newTile);
        }
        
        function handleCanvasClick(e) {
            if (isPanning) return; // Don't place tiles while panning
            
            // If we were painting (drag operation), the tiles are already placed
            // Just reset the painting state and return
            if (isPainting) {
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert screen coordinates to grid coordinates accounting for zoom and pan
            const cellPixels = canvas.width / gridSize;
            const gridX = Math.floor((x - panX) / zoomLevel / cellPixels);
            const gridY = Math.floor((y - panY) / zoomLevel / cellPixels);
            
            // Handle select tool - click on existing tiles to select/edit them
            if (currentTool === 'select') {
                // Find tile at this position
                const clickedTile = mapData.tiles.find(t => t.gridX === gridX && t.gridY === gridY);
                
                if (clickedTile && clickedTile.type === 'npc-spawn') {
                    // Open schedule editor for this NPC
                    openScheduleEditor(clickedTile);
                    
                    // Set appropriate waypoint time
                    const lastTime = getLastWaypointTime();
                    if (lastTime > 0) {
                        const nextTime = lastTime + 15;
                        if (nextTime < 24 * 60) {
                            document.getElementById('waypoint-time').value = minutesToTimeString(nextTime);
                        }
                    } else {
                        document.getElementById('waypoint-time').value = '06:15';
                    }
                    
                    console.log('Selected NPC spawn:', clickedTile);
                    drawGrid();
                    return;
                } else if (clickedTile) {
                    console.log('Selected tile:', clickedTile);
                    // Could add other tile selection logic here
                    return;
                } else {
                    console.log('No tile at position:', gridX, gridY);
                    return;
                }
            }
            
            // Handle schedule mode
            if (scheduleMode) {
                if (!selectedNpcSpawn) {
                    alert('Please select an NPC spawn first!');
                    return;
                }
                
                // Get time from input
                const timeInput = document.getElementById('waypoint-time');
                const timeStr = timeInput.value;
                
                if (!timeStr) {
                    alert('Please select a time for this waypoint!');
                    return;
                }
                
                const timeMinutes = timeStringToMinutes(timeStr);
                const lastTime = getLastWaypointTime();
                
                // Validate that time is after the last waypoint (only if there are existing waypoints)
                if (lastTime > 0 && timeMinutes <= lastTime) {
                    alert(`Time must be after ${minutesToTimeString(lastTime)} (the last waypoint)`);
                    return;
                }
                
                addScheduleWaypoint(gridX, gridY, timeMinutes);
                
                // Auto-increment time by 15 minutes for next waypoint
                const nextTime = timeMinutes + 15;
                if (nextTime < 24 * 60) {
                    timeInput.value = minutesToTimeString(nextTime);
                }
                
                drawGrid();
                return;
            }
            
            // Handle paintable tools (wall, floor, window, erase) - already handled above
            const paintableTools = ['wall', 'floor', 'window', 'erase'];
            if (paintableTools.includes(currentTool)) {
                placeTile(gridX, gridY, currentTool);
                drawGrid();
                updateJSON();
                return;
            }
            
            // Handle special tools (door, player-spawn, npc-spawn)
            // Get tile size for this tool
            const tileGridSize = TILE_GRID_SIZES[currentTool] || 1;
            
            // Remove existing tiles at this position
            mapData.tiles = mapData.tiles.filter(t => !(t.gridX === gridX && t.gridY === gridY));
            
            // Calculate world position
            let worldX, worldZ;
            if (tileGridSize === 2) {
                    // For 2-cell tiles, position at the center between two cells
                    // Rotation determines which direction the tile spans
                    if (currentRotation === 0 || currentRotation === 180) {
                        // Horizontal span (along X axis)
                        worldX = (gridX - gridSize / 2) * CELL_SIZE + CELL_SIZE / 2;
                        worldZ = (gridY - gridSize / 2) * CELL_SIZE;
                    } else {
                        // Vertical span (along Z axis)
                        worldX = (gridX - gridSize / 2) * CELL_SIZE;
                        worldZ = (gridY - gridSize / 2) * CELL_SIZE + CELL_SIZE / 2;
                    }
                } else {
                    // Single-cell tiles
                    worldX = (gridX - gridSize / 2) * CELL_SIZE;
                    worldZ = (gridY - gridSize / 2) * CELL_SIZE;
                }
                
                const newTile = {
                    type: currentTool,
                    gridX: gridX,
                    gridY: gridY,
                    worldX: worldX,
                    worldZ: worldZ
                };
                
                // Add rotation for walls, doors, windows, and spawns
                if (currentTool === 'wall' || currentTool === 'door' || currentTool === 'window' || 
                    currentTool === 'npc-spawn' || currentTool === 'player-spawn') {
                    newTile.rotation = currentRotation;
                }
                
                // Handle player spawn - only allow one, replace existing
                if (currentTool === 'player-spawn') {
                    // Remove any existing player spawn
                    mapData.tiles = mapData.tiles.filter(t => t.type !== 'player-spawn');
                    mapData.tiles.push(newTile);
                    drawGrid();
                    updateJSON();
                    return;
                }
                
                // Handle door - can be placed normally
                if (currentTool === 'door') {
                    mapData.tiles.push(newTile);
                    drawGrid();
                    updateJSON();
                    return;
                }
                
                // Store NPC type for NPC spawns
                if (currentTool === 'npc-spawn') {
                    newTile.npcType = currentNpcType;
                    
                    // Add the NPC spawn
                    mapData.tiles.push(newTile);
                    
                    // Open schedule editor for this new NPC
                    openScheduleEditor(newTile);
                    
                    // Add the NPC spawn position as the first waypoint at 6:00 AM
                    const firstWaypointTime = 6 * 60; // 6:00 AM in minutes
                    addScheduleWaypoint(gridX, gridY, firstWaypointTime);
                    
                    // Set next waypoint time to 6:15 AM
                    document.getElementById('waypoint-time').value = '06:15';
                    
                    drawGrid();
                    updateJSON();
                    return;
                }
            
            // If we get here, we should never reach - all tools are handled above
            console.warn('Unhandled tool:', currentTool);
        }
        
        function handleCanvasHover(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Account for zoom and pan transforms (same logic as handleCanvasClick)
            const cellPixels = canvas.width / gridSize;
            const gridX = Math.floor((x - panX) / zoomLevel / cellPixels);
            const gridY = Math.floor((y - panY) / zoomLevel / cellPixels);
            
            // Update cursor position and redraw if changed
            if (cursorGridX !== gridX || cursorGridY !== gridY) {
                cursorGridX = gridX;
                cursorGridY = gridY;
                drawGrid();
            }
            
            canvas.title = `Grid: (${gridX}, ${gridY}) | World: (${(gridX - gridSize/2) * CELL_SIZE}, ${(gridY - gridSize/2) * CELL_SIZE}) | Rotation: ${currentRotation}¬∞`;
        }
        
        function forceRedrawPreview() {
            // Force a redraw of the grid and preview
            if (cursorGridX >= 0 && cursorGridY >= 0) {
                drawGrid();
            }
        }
        
        // Schedule editing helper functions
        function getNpcScheduleKey(npcTile) {
            return `${npcTile.gridX}_${npcTile.gridY}`;
        }
        
        function selectNpcSpawnForSchedule(npcTile) {
            selectedNpcSpawn = npcTile;
            const scheduleKey = getNpcScheduleKey(npcTile);
            if (!npcSchedules.has(scheduleKey)) {
                npcSchedules.set(scheduleKey, []);
            }
            updateScheduleList();
        }
        
        function timeStringToMinutes(timeStr) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }
        
        function minutesToTimeString(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
        }
        
        function getLastWaypointTime() {
            if (!selectedNpcSpawn) return 0;
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            if (waypoints.length === 0) return 0;
            return Math.max(...waypoints.map(w => w.timeMinutes));
        }
        
        function addScheduleWaypoint(gridX, gridY, timeMinutes) {
            if (!selectedNpcSpawn) return;
            
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            
            // Calculate world position
            const worldX = (gridX - gridSize / 2) * CELL_SIZE;
            const worldZ = (gridY - gridSize / 2) * CELL_SIZE;
            
            waypoints.push({
                gridX,
                gridY,
                worldX,
                worldZ,
                timeMinutes,
                timeString: minutesToTimeString(timeMinutes)
            });
            
            // Sort by time
            waypoints.sort((a, b) => a.timeMinutes - b.timeMinutes);
            npcSchedules.set(scheduleKey, waypoints);
            
            updateScheduleList();
            updateJSON(); // Update JSON to reflect new waypoint
        }
        
        function updateScheduleList() {
            const listDiv = document.getElementById('schedule-list');
            if (!selectedNpcSpawn) {
                listDiv.innerHTML = '<em style="color: #999;">No NPC selected</em>';
                return;
            }
            
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            
            if (waypoints.length === 0) {
                listDiv.innerHTML = '<em style="color: #999;">No waypoints yet</em>';
                return;
            }
            
            listDiv.innerHTML = waypoints.map((wp, idx) => `
                <div style="padding: 5px; margin: 2px 0; background: #3a3a3a; border-radius: 3px; display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                    <span style="min-width: 25px;">${idx + 1}.</span>
                    <input type="time" value="${wp.timeString}" onchange="updateWaypointTime(${idx}, this.value)" 
                           style="padding: 4px 6px; background: #1a1a1a; border: 1px solid #555; color: #fff; border-radius: 3px; font-size: 12px;">
                    <span style="color: #888; font-size: 12px;">@ (${wp.gridX}, ${wp.gridY})</span>
                    <button onclick="removeWaypoint(${idx})" style="padding: 2px 8px; background: #d32f2f; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: auto;">√ó</button>
                </div>
            `).join('');
        }
        
        function updateWaypointTime(index, newTimeString) {
            if (!selectedNpcSpawn) return;
            
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            
            if (index < 0 || index >= waypoints.length) return;
            
            const newTimeMinutes = timeStringToMinutes(newTimeString);
            
            // Validate: Check that the new time doesn't conflict with adjacent waypoints
            if (index > 0) {
                const prevTime = waypoints[index - 1].timeMinutes;
                if (newTimeMinutes <= prevTime) {
                    alert(`Time must be after ${minutesToTimeString(prevTime)} (previous waypoint)`);
                    updateScheduleList(); // Revert the display
                    return;
                }
            }
            
            if (index < waypoints.length - 1) {
                const nextTime = waypoints[index + 1].timeMinutes;
                if (newTimeMinutes >= nextTime) {
                    alert(`Time must be before ${minutesToTimeString(nextTime)} (next waypoint)`);
                    updateScheduleList(); // Revert the display
                    return;
                }
            }
            
            // Update the waypoint
            waypoints[index].timeMinutes = newTimeMinutes;
            waypoints[index].timeString = newTimeString;
            
            // Re-sort by time (in case user edited it significantly)
            waypoints.sort((a, b) => a.timeMinutes - b.timeMinutes);
            npcSchedules.set(scheduleKey, waypoints);
            
            updateScheduleList();
            drawGrid();
            updateJSON();
            
            console.log(`Updated waypoint ${index + 1} to ${newTimeString}`);
        }
        
        function removeWaypoint(index) {
            if (!selectedNpcSpawn) return;
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            waypoints.splice(index, 1);
            npcSchedules.set(scheduleKey, waypoints);
            updateScheduleList();
            drawGrid();
        }
        
        function updateJSON() {
            // Group tiles by type for better organization
            const groupedData = {
                metadata: mapData.metadata,
                buildings: [],
                spawns: {
                    player: [],
                    npcs: []
                }
            };
            
            mapData.tiles.forEach(tile => {
                if (tile.type === 'player-spawn') {
                    const playerSpawn = {
                        x: tile.worldX,
                        y: 0,
                        z: tile.worldZ
                    };
                    // Add rotation if present
                    if (tile.rotation !== undefined && tile.rotation !== 0) {
                        playerSpawn.rotation = tile.rotation;
                    }
                    groupedData.spawns.player.push(playerSpawn);
                } else if (tile.type === 'npc-spawn') {
                    const npcSpawn = {
                        x: tile.worldX,
                        y: 0,
                        z: tile.worldZ,
                        npcId: tile.npcType || "baker" // Use stored npcType, default to baker
                    };
                    // Add rotation if present
                    if (tile.rotation !== undefined && tile.rotation !== 0) {
                        npcSpawn.rotation = tile.rotation;
                    }
                    
                    // Add schedule if it exists
                    const scheduleKey = getNpcScheduleKey(tile);
                    const waypoints = npcSchedules.get(scheduleKey);
                    if (waypoints && waypoints.length > 0) {
                        npcSpawn.schedule = {};
                        waypoints.forEach(wp => {
                            // Convert time in minutes to seconds for the schedule format
                            const timeInSeconds = wp.timeMinutes * 60;
                            npcSpawn.schedule[timeInSeconds] = {
                                x: wp.worldX,
                                y: 0,
                                z: wp.worldZ
                            };
                        });
                    }
                    
                    groupedData.spawns.npcs.push(npcSpawn);
                } else {
                    const building = {
                        type: tile.type,
                        position: {
                            x: tile.worldX,
                            y: 0,
                            z: tile.worldZ
                        },
                        gridPosition: {
                            x: tile.gridX,
                            y: tile.gridY
                        }
                    };
                    
                    // Add rotation if present
                    if (tile.rotation !== undefined && tile.rotation !== 0) {
                        building.rotation = tile.rotation;
                    }
                    
                    groupedData.buildings.push(building);
                }
            });
            
            document.getElementById('jsonOutput').value = JSON.stringify(groupedData, null, 2);
        }
        
        function copyToClipboard() {
            const output = document.getElementById('jsonOutput');
            output.select();
            document.execCommand('copy');
            alert('Map data copied to clipboard!');
        }
        
        function downloadJSON() {
            const data = document.getElementById('jsonOutput').value;
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `map_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function importJSON() {
            // Trigger the hidden file input
            document.getElementById('import-file-input').click();
        }
        
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    loadMapFromJSON(jsonData);
                    alert('Map imported successfully!');
                } catch (error) {
                    console.error('Error importing map:', error);
                    alert('Error importing map: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset the file input so the same file can be imported again if needed
            event.target.value = '';
        }
        
        function loadMapFromJSON(jsonData) {
            // Clear existing data
            mapData.tiles = [];
            npcSchedules.clear();
            closeScheduleEditor();
            
            // Update metadata if present
            if (jsonData.metadata) {
                mapData.metadata = jsonData.metadata;
                if (jsonData.metadata.gridSize) {
                    gridSize = jsonData.metadata.gridSize;
                    document.getElementById('gridSize').value = gridSize;
                    updateGridSize();
                }
            }
            
            // Import buildings
            if (jsonData.buildings && Array.isArray(jsonData.buildings)) {
                jsonData.buildings.forEach(building => {
                    const tile = {
                        type: building.type,
                        gridX: building.gridPosition?.x || Math.floor((building.position.x / CELL_SIZE) + gridSize / 2),
                        gridY: building.gridPosition?.y || Math.floor((building.position.z / CELL_SIZE) + gridSize / 2),
                        worldX: building.position.x,
                        worldZ: building.position.z
                    };
                    
                    if (building.rotation !== undefined) {
                        tile.rotation = building.rotation;
                    }
                    
                    mapData.tiles.push(tile);
                });
            }
            
            // Import player spawn
            if (jsonData.spawns?.player && Array.isArray(jsonData.spawns.player) && jsonData.spawns.player.length > 0) {
                const playerSpawn = jsonData.spawns.player[0];
                const tile = {
                    type: 'player-spawn',
                    gridX: Math.floor((playerSpawn.x / CELL_SIZE) + gridSize / 2),
                    gridY: Math.floor((playerSpawn.z / CELL_SIZE) + gridSize / 2),
                    worldX: playerSpawn.x,
                    worldZ: playerSpawn.z,
                    rotation: playerSpawn.rotation || 0
                };
                mapData.tiles.push(tile);
            }
            
            // Import NPC spawns with schedules
            if (jsonData.spawns?.npcs && Array.isArray(jsonData.spawns.npcs)) {
                jsonData.spawns.npcs.forEach(npcSpawn => {
                    const tile = {
                        type: 'npc-spawn',
                        gridX: Math.floor((npcSpawn.x / CELL_SIZE) + gridSize / 2),
                        gridY: Math.floor((npcSpawn.z / CELL_SIZE) + gridSize / 2),
                        worldX: npcSpawn.x,
                        worldZ: npcSpawn.z,
                        npcType: npcSpawn.npcId || 'baker',
                        rotation: npcSpawn.rotation || 0
                    };
                    mapData.tiles.push(tile);
                    
                    // Import schedule if present
                    if (npcSpawn.schedule && typeof npcSpawn.schedule === 'object') {
                        const scheduleKey = getNpcScheduleKey(tile);
                        const waypoints = [];
                        
                        // Convert schedule object to waypoint array
                        Object.entries(npcSpawn.schedule).forEach(([timeInSeconds, position]) => {
                            const timeMinutes = Math.floor(parseInt(timeInSeconds) / 60);
                            const gridX = Math.floor((position.x / CELL_SIZE) + gridSize / 2);
                            const gridY = Math.floor((position.z / CELL_SIZE) + gridSize / 2);
                            
                            waypoints.push({
                                gridX: gridX,
                                gridY: gridY,
                                worldX: position.x,
                                worldZ: position.z,
                                timeMinutes: timeMinutes,
                                timeString: minutesToTimeString(timeMinutes)
                            });
                        });
                        
                        // Sort by time
                        waypoints.sort((a, b) => a.timeMinutes - b.timeMinutes);
                        npcSchedules.set(scheduleKey, waypoints);
                    }
                });
            }
            
            // Redraw and update
            drawGrid();
            updateJSON();
            
            console.log('Map imported:', mapData);
        }
        
        function clearMap() {
            if (confirm('Are you sure you want to clear the entire map?')) {
                mapData.tiles = [];
                npcSchedules.clear();
                
                // Close schedule editor
                closeScheduleEditor();
                
                // Add default player spawn in the center
                const centerGridX = Math.floor(gridSize / 2);
                const centerGridY = Math.floor(gridSize / 2);
                const centerWorldX = 0; // Center of the world
                const centerWorldZ = 0; // Center of the world
                
                mapData.tiles.push({
                    type: 'player-spawn',
                    gridX: centerGridX,
                    gridY: centerGridY,
                    worldX: centerWorldX,
                    worldZ: centerWorldZ,
                    rotation: 0 // Facing south by default
                });
                
                drawGrid();
                updateJSON();
            }
        }
        
        // Initialize on load
        init();
    </script>
</body>
</html>
