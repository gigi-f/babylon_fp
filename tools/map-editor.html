<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon FP - Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #4CAF50;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: inline-block;
            width: 120px;
            color: #aaa;
        }
        
        .control-group input,
        .control-group select {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .tool-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .tool-btn {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }
        
        .tool-btn:hover {
            border-color: #4CAF50;
            background: #444;
        }
        
        .tool-btn.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .canvas-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: auto;
        }
        
        #mapCanvas {
            background: #1a1a1a;
            border: 2px solid #444;
            cursor: crosshair;
        }
        
        .export-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }
        
        .export-section h2 {
            color: #4CAF50;
            margin-bottom: 15px;
        }
        
        #jsonOutput {
            width: 100%;
            height: 300px;
            background: #1a1a1a;
            color: #4CAF50;
            border: 1px solid #444;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .action-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            background: #4CAF50;
            color: #000;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        .action-btn:hover {
            background: #45a049;
        }
        
        .legend {
            background: #2a2a2a;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        .legend h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }
        
        .legend-items {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .legend-item:hover {
            background-color: #333;
        }
        
        .legend-item.active {
            background-color: #4CAF50;
        }
        
        .legend-color {
            width: 30px;
            height: 30px;
            border: 1px solid #fff;
        }
        
        .minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: #1a1a1a;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }
        
        .minimap.visible {
            display: block;
        }
        
        .minimap canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèóÔ∏è Babylon FP Map Editor</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Grid Size:</label>
                <input type="number" id="gridSize" value="100" min="10" max="200">
                <span id="worldInfo" style="color: #666; margin-left: 10px;"></span>
            </div>
            
            <div class="control-group">
                <label>Zoom:</label>
                <input type="range" id="zoom" min="1" max="5" step="0.5" value="1">
                <span id="zoomLevel" style="color: #666; margin-left: 10px;">100%</span>
                <span style="color: #666; margin-left: 10px;">Scroll wheel to zoom</span>
                <button id="resetView" style="margin-left: 15px; padding: 5px 10px; background: #555; color: white; border: 1px solid #666; border-radius: 4px; cursor: pointer;">Reset View</button>
            </div>
            
            <div class="control-group">
                <label>Rotation:</label>
                <select id="rotation">
                    <option value="0">0¬∞ (Horizontal)</option>
                    <option value="90">90¬∞ (Vertical)</option>
                    <option value="180">180¬∞</option>
                    <option value="270">270¬∞</option>
                </select>
                <span style="color: #666; margin-left: 10px;">Press 'R' to rotate</span>
            </div>
            
            <div class="control-group">
                <label for="npc-type-select">NPC Type:</label>
                <select id="npc-type-select">
                    <option value="baker">ü•ñ Baker</option>
                    <option value="guard">üõ°Ô∏è Guard</option>
                    <option value="beggar">ü™ô Beggar</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="schedule-mode-toggle"> 
                    Schedule Editor Mode
                </label>
                <div id="schedule-editor" style="display: none; margin-top: 10px; padding: 10px; background: #2a2a2a; border-radius: 4px;">
                    <div style="margin-bottom: 10px;">
                        <label for="waypoint-time" style="display: block; margin-bottom: 5px;">Waypoint Time:</label>
                        <input type="time" id="waypoint-time" style="width: 100%; padding: 5px;">
                        <small style="color: #999; display: block; margin-top: 5px;">
                            Click on the map to place a schedule waypoint
                        </small>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>Current Schedule:</strong>
                        <div id="schedule-list" style="max-height: 200px; overflow-y: auto; margin-top: 5px;">
                            <em style="color: #999;">No waypoints yet. Place an NPC spawn first.</em>
                        </div>
                    </div>
                    <button id="clear-schedule" style="width: 100%; padding: 8px; background: #d32f2f; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Clear Schedule
                    </button>
                </div>
            </div>
            
            <div class="control-group">
                <label>Brush Tool:</label>
            </div>
            <div class="tool-buttons">
                <button class="tool-btn active" data-tool="wall">üß± Wall</button>
                <button class="tool-btn" data-tool="floor">‚¨ú Floor</button>
                <button class="tool-btn" data-tool="door">üö™ Door</button>
                <button class="tool-btn" data-tool="window">ü™ü Window</button>
                <button class="tool-btn" data-tool="npc-spawn">üë§ NPC Spawn</button>
                <button class="tool-btn" data-tool="player-spawn">üéÆ Player Spawn</button>
                <button class="tool-btn" data-tool="erase">‚ùå Erase</button>
            </div>
        </div>
        
        <div class="legend">
            <h3>Legend</h3>
            <div class="legend-items">
                <div class="legend-item" data-tool="wall">
                    <div class="legend-color" style="background: #666;"></div>
                    <span>Wall</span>
                </div>
                <div class="legend-item" data-tool="floor">
                    <div class="legend-color" style="background: #ddd;"></div>
                    <span>Floor</span>
                </div>
                <div class="legend-item" data-tool="door">
                    <div class="legend-color" style="background: #8B4513;"></div>
                    <span>Door</span>
                </div>
                <div class="legend-item" data-tool="window">
                    <div class="legend-color" style="background: #87CEEB;"></div>
                    <span>Window</span>
                </div>
                <div class="legend-item" data-tool="npc-spawn">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>NPC Spawn</span>
                </div>
                <div class="legend-item" data-tool="player-spawn">
                    <div class="legend-color" style="background: #FF4444;"></div>
                    <span>Player Spawn</span>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="mapCanvas"></canvas>
        </div>
        
        <!-- Minimap (shown when zoomed) -->
        <div class="minimap" id="minimap">
            <canvas id="minimapCanvas" width="200" height="200"></canvas>
        </div>
        
        <div class="export-section">
            <h2>Export Map Data</h2>
            <textarea id="jsonOutput" readonly></textarea>
            <div class="action-buttons">
                <button class="action-btn" onclick="copyToClipboard()">üìã Copy JSON</button>
                <button class="action-btn" onclick="downloadJSON()">üíæ Download JSON</button>
                <button class="action-btn" onclick="clearMap()">üóëÔ∏è Clear Map</button>
            </div>
        </div>
    </div>

    <script>
        // Shared world constants - must match src/config/worldConstants.ts
        const GRID_CELL_SIZE = 1; // Each grid cell = 1 unit in 3D world space
        const WALL_WIDTH = 1.0; // Width of walls (1 cell wide)
        const DOOR_WIDTH = 2.0; // Width of doors (2 cells wide for player to fit)
        const WINDOW_WIDTH = 1.0; // Width of windows (1 cell wide)
        
        // Tile size in grid cells (how many cells each tile type occupies)
        const TILE_GRID_SIZES = {
            'wall': 1,
            'floor': 1,
            'door': 2,  // Doors occupy 2 grid cells
            'window': 1,
            'npc-spawn': 1,
            'player-spawn': 1,
            'erase': 1
        };
        
        // Map editor configuration
        const CELL_SIZE = GRID_CELL_SIZE; // Alias for backwards compatibility
        let gridSize = 100; // 100x100 grid
        let currentTool = 'wall';
        let currentRotation = 0; // 0, 90, 180, 270
        let currentNpcType = 'baker'; // Default NPC type
        let cursorGridX = -1;
        let cursorGridY = -1;
        
        // Schedule editing state
        let scheduleMode = false;
        let selectedNpcSpawn = null; // The NPC spawn tile we're editing schedule for
        let npcSchedules = new Map(); // Map of npc spawn tile ID -> array of waypoints
        
        // Zoom and Pan
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;
        
        // Map data
        const mapData = {
            metadata: {
                gridSize: 100,
                cellSize: 1,
                worldSize: 100,
                version: "1.0.0"
            },
            tiles: []
        };
        
        // Canvas setup
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        
        // Colors for different tile types
        const tileColors = {
            wall: '#666',
            floor: '#ddd',
            door: '#8B4513',
            window: '#87CEEB',
            'npc-spawn': '#FFD700',
            'player-spawn': '#FF4444'
        };
        
        // NPC-specific colors
        const npcColors = {
            baker: '#D2691E',    // Tan/brown for baker
            guard: '#4169E1',    // Royal blue for guard
            beggar: '#8B8B8B'    // Gray for beggar
        };
        
        // Get color for a tile (handles NPC-specific colors)
        function getTileColor(tile) {
            if (tile.type === 'npc-spawn' && tile.npcType) {
                return npcColors[tile.npcType] || tileColors['npc-spawn'];
            }
            return tileColors[tile.type] || '#fff';
        }
        
        // Initialize
        function init() {
            updateGridSize();
            drawGrid();
            updateJSON();
            
            // Set default time for schedule waypoints
            document.getElementById('waypoint-time').value = '00:00';
            
            // Set initial active state for legend item (wall is default)
            const initialLegend = document.querySelector('.legend-item[data-tool="wall"]');
            if (initialLegend) initialLegend.classList.add('active');
            
            // Event listeners
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mouseleave', () => {
                cursorGridX = -1;
                cursorGridY = -1;
                isPanning = false;
                drawGrid();
            });
            
            // Pan with middle mouse button only
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 1) { // Middle mouse button only
                    e.preventDefault();
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 1) {
                    isPanning = false;
                    canvas.style.cursor = 'crosshair';
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    e.preventDefault();
                    const dx = e.clientX - lastPanX;
                    const dy = e.clientY - lastPanY;
                    
                    // Apply pan with bounds checking
                    const newPanX = panX + dx;
                    const newPanY = panY + dy;
                    
                    // Calculate bounds - allow panning up to half a canvas width/height beyond the grid edges
                    const maxPan = canvas.width * 0.5;
                    const minPan = -(canvas.width * zoomLevel) + maxPan;
                    
                    // Clamp pan values to bounds
                    panX = Math.max(minPan, Math.min(maxPan, newPanX));
                    panY = Math.max(minPan, Math.min(maxPan, newPanY));
                    
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    drawGrid();
                    return; // Don't process hover while panning
                }
                
                // Handle normal hover
                handleCanvasHover(e);
            });
            
            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                zoomLevel = Math.max(1, Math.min(5, zoomLevel + delta));
                document.getElementById('zoom').value = zoomLevel;
                updateZoomDisplay();
                drawGrid();
            }, { passive: false });
            
            // Shared function to select a tool
            function selectTool(tool) {
                currentTool = tool;
                
                // Update button states
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                const activeBtn = document.querySelector(`.tool-btn[data-tool="${tool}"]`);
                if (activeBtn) activeBtn.classList.add('active');
                
                // Update legend item states
                document.querySelectorAll('.legend-item').forEach(l => l.classList.remove('active'));
                const activeLegend = document.querySelector(`.legend-item[data-tool="${tool}"]`);
                if (activeLegend) activeLegend.classList.add('active');
                
                drawGrid(); // Redraw to show new preview
            }
            
            // Tool button click handlers
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    selectTool(e.target.dataset.tool);
                });
            });
            
            // Legend item click handlers
            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const tool = e.currentTarget.dataset.tool;
                    selectTool(tool);
                });
            });
            
            document.getElementById('gridSize').addEventListener('change', (e) => {
                gridSize = parseInt(e.target.value);
                updateGridSize();
            });
            
            document.getElementById('zoom').addEventListener('input', (e) => {
                zoomLevel = parseFloat(e.target.value);
                updateZoomDisplay();
                drawGrid();
            });
            
            document.getElementById('resetView').addEventListener('click', () => {
                zoomLevel = 1;
                panX = 0;
                panY = 0;
                document.getElementById('zoom').value = '1';
                updateZoomDisplay();
                drawGrid();
            });
            
            document.getElementById('rotation').addEventListener('change', (e) => {
                currentRotation = parseInt(e.target.value);
                drawGrid(); // Redraw to show new orientation
            });
            
            // NPC type selector
            document.getElementById('npc-type-select').addEventListener('change', (e) => {
                currentNpcType = e.target.value;
            });
            
            // Schedule mode toggle
            document.getElementById('schedule-mode-toggle').addEventListener('change', (e) => {
                scheduleMode = e.target.checked;
                document.getElementById('schedule-editor').style.display = scheduleMode ? 'block' : 'none';
                
                if (scheduleMode) {
                    // When entering schedule mode, try to find an NPC spawn to edit
                    const npcSpawns = mapData.tiles.filter(t => t.type === 'npc-spawn');
                    if (npcSpawns.length > 0) {
                        selectNpcSpawnForSchedule(npcSpawns[0]);
                    } else {
                        alert('Please place an NPC spawn on the map first!');
                        e.target.checked = false;
                        scheduleMode = false;
                        document.getElementById('schedule-editor').style.display = 'none';
                    }
                }
                drawGrid();
            });
            
            // Clear schedule button
            document.getElementById('clear-schedule').addEventListener('click', () => {
                if (selectedNpcSpawn && confirm('Clear all waypoints for this NPC?')) {
                    const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
                    npcSchedules.delete(scheduleKey);
                    updateScheduleList();
                    drawGrid();
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'r' || e.key === 'R') {
                    currentRotation = (currentRotation + 90) % 360;
                    document.getElementById('rotation').value = currentRotation;
                    drawGrid(); // Redraw to show new orientation
                }
            });
        }
        
        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = `${Math.round(zoomLevel * 100)}%`;
            
            // Show/hide minimap based on zoom level
            if (zoomLevel > 1.5) {
                minimap.classList.add('visible');
                drawMinimap();
            } else {
                minimap.classList.remove('visible');
            }
        }
        
        function updateGridSize() {
            const size = gridSize * 10; // 10 pixels per cell for visibility
            canvas.width = size;
            canvas.height = size;
            mapData.metadata.gridSize = gridSize;
            mapData.metadata.worldSize = gridSize * CELL_SIZE;
            
            // Reset pan when grid size changes
            panX = 0;
            panY = 0;
            
            // Update world info display
            const worldInfo = document.getElementById('worldInfo');
            worldInfo.textContent = `(World: ${mapData.metadata.worldSize}x${mapData.metadata.worldSize}, Cell size: ${CELL_SIZE} units)`;
            
            drawGrid();
        }
        
        function drawGrid() {
            const cellPixels = canvas.width / gridSize; // Base cell size without zoom
            
            // Save context state
            ctx.save();
            
            // Apply zoom and pan transforms
            ctx.translate(panX, panY);
            ctx.scale(zoomLevel, zoomLevel);
            
            // Clear canvas (must clear before transform)
            ctx.fillStyle = '#1a1a1a';
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for clear
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.setTransform(zoomLevel, 0, 0, zoomLevel, panX, panY); // Re-apply transform
            
            // Draw tiles
            mapData.tiles.forEach(tile => {
                const x = tile.gridX * cellPixels;
                const y = tile.gridY * cellPixels;
                drawTileWithOrientation(tile, x, y, cellPixels);
            });
            
            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= gridSize; i++) {
                const pos = i * cellPixels;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(canvas.width, pos);
                ctx.stroke();
            }
            
            // Draw coordinate labels every 10 cells
            ctx.fillStyle = '#666';
            ctx.font = '10px Courier New';
            for (let i = 0; i <= gridSize; i += 10) {
                const pos = i * cellPixels;
                ctx.fillText(i.toString(), pos + 2, 10);
                ctx.fillText(i.toString(), 2, pos + 10);
            }
            
            // Draw cursor preview
            if (cursorGridX >= 0 && cursorGridY >= 0 && cursorGridX < gridSize && cursorGridY < gridSize) {
                drawCursorPreview(cursorGridX, cursorGridY, cellPixels);
            }
            
            // Draw schedule waypoints and paths
            if (scheduleMode && selectedNpcSpawn) {
                drawScheduleWaypoints(cellPixels);
            }
            
            // Restore context state
            ctx.restore();
            
            // Draw minimap if zoomed in
            if (zoomLevel > 1.5) {
                drawMinimap();
            }
        }
        
        function drawScheduleWaypoints(cellPixels) {
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            
            if (waypoints.length === 0) return;
            
            // Draw connecting lines first (so they're behind the waypoint dots)
            ctx.strokeStyle = '#ff3333';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            for (let i = 0; i < waypoints.length - 1; i++) {
                const wp1 = waypoints[i];
                const wp2 = waypoints[i + 1];
                
                const x1 = wp1.gridX * cellPixels + cellPixels / 2;
                const y1 = wp1.gridY * cellPixels + cellPixels / 2;
                const x2 = wp2.gridX * cellPixels + cellPixels / 2;
                const y2 = wp2.gridY * cellPixels + cellPixels / 2;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Draw loop back to start
            if (waypoints.length > 1) {
                const wpLast = waypoints[waypoints.length - 1];
                const wpFirst = waypoints[0];
                
                const x1 = wpLast.gridX * cellPixels + cellPixels / 2;
                const y1 = wpLast.gridY * cellPixels + cellPixels / 2;
                const x2 = wpFirst.gridX * cellPixels + cellPixels / 2;
                const y2 = wpFirst.gridY * cellPixels + cellPixels / 2;
                
                ctx.strokeStyle = '#ff6666';
                ctx.setLineDash([2, 8]);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // Draw waypoint tiles
            waypoints.forEach((wp, idx) => {
                const x = wp.gridX * cellPixels;
                const y = wp.gridY * cellPixels;
                
                // Red tile
                ctx.fillStyle = '#ff3333';
                ctx.fillRect(x, y, cellPixels, cellPixels);
                
                // White border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, cellPixels, cellPixels);
                
                // Time label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(wp.timeString, x + cellPixels / 2, y + cellPixels / 2);
                
                // Waypoint number
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`#${idx + 1}`, x + 2, y + 2);
            });
        }
        
        function drawCursorPreview(gridX, gridY, cellPixels) {
            const x = gridX * cellPixels;
            const y = gridY * cellPixels;
            
            // In schedule mode, show red preview
            if (scheduleMode) {
                ctx.fillStyle = '#ff3333';
                ctx.globalAlpha = 0.7;
                ctx.fillRect(x, y, cellPixels, cellPixels);
                ctx.globalAlpha = 1.0;
                
                // Show time label
                const timeInput = document.getElementById('waypoint-time');
                if (timeInput.value) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(timeInput.value, x + cellPixels / 2, y + cellPixels / 2);
                }
                return;
            }
            
            if (currentTool === 'erase') {
                // Red X for erase
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + cellPixels, y + cellPixels);
                ctx.moveTo(x + cellPixels, y);
                ctx.lineTo(x, y + cellPixels);
                ctx.stroke();
                return;
            }
            
            // Get tile size for this tool
            const tileGridSize = TILE_GRID_SIZES[currentTool] || 1;
            
            // Draw semi-transparent preview of the tile
            // Use NPC-specific color if placing an NPC spawn
            if (currentTool === 'npc-spawn') {
                ctx.fillStyle = npcColors[currentNpcType] || tileColors[currentTool] || '#fff';
            } else {
                ctx.fillStyle = tileColors[currentTool] || '#fff';
            }
            ctx.globalAlpha = 0.5;
            
            // For 2-cell tiles, draw based on rotation
            if (tileGridSize === 2) {
                if (currentRotation === 0 || currentRotation === 180) {
                    // Horizontal span (2 cells wide along X)
                    ctx.fillRect(x, y, cellPixels * 2, cellPixels);
                } else {
                    // Vertical span (2 cells tall along Y)
                    ctx.fillRect(x, y, cellPixels, cellPixels * 2);
                }
            } else {
                // Single cell
                ctx.fillRect(x, y, cellPixels, cellPixels);
            }
            
            ctx.globalAlpha = 1.0;
            
            // Draw orientation indicator for rotatable items
            if (currentTool === 'wall' || currentTool === 'door' || currentTool === 'window' ||
                currentTool === 'npc-spawn' || currentTool === 'player-spawn') {
                // Use currentRotation for all rotatable items including spawns
                const width = (tileGridSize === 2 && (currentRotation === 0 || currentRotation === 180)) ? cellPixels * 2 : cellPixels;
                const height = (tileGridSize === 2 && (currentRotation === 90 || currentRotation === 270)) ? cellPixels * 2 : cellPixels;
                drawOrientationIndicator(x, y, width, height, currentRotation);
            }
        }
        
        function drawOrientationIndicator(x, y, width, height, rotation) {
            // Bright green line on the "front" edge
            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            
            // Draw line based on rotation
            // 0¬∞ = front faces down (south), line at bottom
            // 90¬∞ = front faces left (west), line at left
            // 180¬∞ = front faces up (north), line at top
            // 270¬∞ = front faces right (east), line at right
            
            switch(rotation) {
                case 0: // Bottom edge (default/south)
                    ctx.moveTo(x, y + height);
                    ctx.lineTo(x + width, y + height);
                    // Draw arrow
                    ctx.moveTo(centerX, y + height);
                    ctx.lineTo(centerX - width/6, y + height - height/4);
                    ctx.moveTo(centerX, y + height);
                    ctx.lineTo(centerX + width/6, y + height - height/4);
                    break;
                case 90: // Left edge (west)
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + height);
                    // Draw arrow
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x + width/4, centerY - height/6);
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x + width/4, centerY + height/6);
                    break;
                case 180: // Top edge (north)
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + width, y);
                    // Draw arrow
                    ctx.moveTo(centerX, y);
                    ctx.lineTo(centerX - width/6, y + height/4);
                    ctx.moveTo(centerX, y);
                    ctx.lineTo(centerX + width/6, y + height/4);
                    break;
                case 270: // Right edge (east)
                    ctx.moveTo(x + width, y);
                    ctx.lineTo(x + width, y + height);
                    // Draw arrow
                    ctx.moveTo(x + width, centerY);
                    ctx.lineTo(x + width - width/4, centerY - height/6);
                    ctx.moveTo(x + width, centerY);
                    ctx.lineTo(x + width - width/4, centerY + height/6);
                    break;
            }
            
            ctx.stroke();
        }
        
        function drawTileWithOrientation(tile, x, y, cellPixels) {
            // Get tile size
            const tileGridSize = TILE_GRID_SIZES[tile.type] || 1;
            
            // Calculate tile dimensions based on size and rotation
            let tileWidth = cellPixels;
            let tileHeight = cellPixels;
            
            if (tileGridSize === 2 && tile.rotation !== undefined) {
                if (tile.rotation === 0 || tile.rotation === 180) {
                    tileWidth = cellPixels * 2;  // Horizontal
                } else {
                    tileHeight = cellPixels * 2;  // Vertical
                }
            }
            
            // Draw the base tile
            ctx.fillStyle = getTileColor(tile);
            ctx.fillRect(x, y, tileWidth, tileHeight);
            
            // Draw orientation if tile has rotation or is a spawn (which should always have rotation)
            const isRotatable = tile.type === 'wall' || tile.type === 'door' || tile.type === 'window' ||
                               tile.type === 'npc-spawn' || tile.type === 'player-spawn';
            
            if (isRotatable && tile.rotation !== undefined) {
                // Use helper function to draw orientation indicator
                drawOrientationIndicator(x, y, tileWidth, tileHeight, tile.rotation);
            }
        }
        
        function drawMinimap() {
            // Clear minimap
            minimapCtx.fillStyle = '#1a1a1a';
            minimapCtx.fillRect(0, 0, 200, 200);
            
            // Scale to fit entire grid
            const scale = 200 / (gridSize * 10);
            minimapCtx.save();
            minimapCtx.scale(scale, scale);
            
            // Draw all tiles
            const cellPixels = (gridSize * 10) / gridSize;
            mapData.tiles.forEach(tile => {
                const x = tile.gridX * cellPixels;
                const y = tile.gridY * cellPixels;
                minimapCtx.fillStyle = getTileColor(tile);
                minimapCtx.fillRect(x, y, cellPixels, cellPixels);
            });
            
            minimapCtx.restore();
            
            // Draw viewport rectangle
            const viewportWidth = (canvas.width / zoomLevel) * scale;
            const viewportHeight = (canvas.height / zoomLevel) * scale;
            const viewportX = (-panX / zoomLevel) * scale;
            const viewportY = (-panY / zoomLevel) * scale;
            
            minimapCtx.strokeStyle = '#4CAF50';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(viewportX, viewportY, viewportWidth, viewportHeight);
        }
        
        function handleCanvasClick(e) {
            if (isPanning) return; // Don't place tiles while panning
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert screen coordinates to grid coordinates accounting for zoom and pan
            const cellPixels = canvas.width / gridSize;
            const gridX = Math.floor((x - panX) / zoomLevel / cellPixels);
            const gridY = Math.floor((y - panY) / zoomLevel / cellPixels);
            
            // Handle schedule mode
            if (scheduleMode) {
                if (!selectedNpcSpawn) {
                    alert('Please select an NPC spawn first!');
                    return;
                }
                
                // Get time from input
                const timeInput = document.getElementById('waypoint-time');
                const timeStr = timeInput.value;
                
                if (!timeStr) {
                    alert('Please select a time for this waypoint!');
                    return;
                }
                
                const timeMinutes = timeStringToMinutes(timeStr);
                const lastTime = getLastWaypointTime();
                
                // Validate that time is after the last waypoint (only if there are existing waypoints)
                if (lastTime > 0 && timeMinutes <= lastTime) {
                    alert(`Time must be after ${minutesToTimeString(lastTime)} (the last waypoint)`);
                    return;
                }
                
                addScheduleWaypoint(gridX, gridY, timeMinutes);
                
                // Auto-increment time by 15 minutes for next waypoint
                const nextTime = timeMinutes + 15;
                if (nextTime < 24 * 60) {
                    timeInput.value = minutesToTimeString(nextTime);
                }
                
                drawGrid();
                return;
            }
            
            if (currentTool === 'erase') {
                // Remove tile at this position
                mapData.tiles = mapData.tiles.filter(t => !(t.gridX === gridX && t.gridY === gridY));
            } else {
                // Get tile size for this tool
                const tileGridSize = TILE_GRID_SIZES[currentTool] || 1;
                
                // Remove existing tiles at this position (and adjacent cells for multi-cell tiles)
                mapData.tiles = mapData.tiles.filter(t => !(t.gridX === gridX && t.gridY === gridY));
                
                // Calculate world position
                // For multi-cell tiles, offset by half a cell to center between the cells
                let worldX, worldZ;
                if (tileGridSize === 2) {
                    // For 2-cell tiles, position at the center between two cells
                    // Rotation determines which direction the tile spans
                    if (currentRotation === 0 || currentRotation === 180) {
                        // Horizontal span (along X axis)
                        worldX = (gridX - gridSize / 2) * CELL_SIZE + CELL_SIZE / 2;
                        worldZ = (gridY - gridSize / 2) * CELL_SIZE;
                    } else {
                        // Vertical span (along Z axis)
                        worldX = (gridX - gridSize / 2) * CELL_SIZE;
                        worldZ = (gridY - gridSize / 2) * CELL_SIZE + CELL_SIZE / 2;
                    }
                } else {
                    // Single-cell tiles
                    worldX = (gridX - gridSize / 2) * CELL_SIZE;
                    worldZ = (gridY - gridSize / 2) * CELL_SIZE;
                }
                
                const newTile = {
                    type: currentTool,
                    gridX: gridX,
                    gridY: gridY,
                    worldX: worldX,
                    worldZ: worldZ
                };
                
                // Add rotation for walls, doors, windows, and spawns
                if (currentTool === 'wall' || currentTool === 'door' || currentTool === 'window' || 
                    currentTool === 'npc-spawn' || currentTool === 'player-spawn') {
                    newTile.rotation = currentRotation;
                }
                
                // Handle player spawn - only allow one, replace existing
                if (currentTool === 'player-spawn') {
                    // Remove any existing player spawn
                    mapData.tiles = mapData.tiles.filter(t => t.type !== 'player-spawn');
                    mapData.tiles.push(newTile);
                    drawGrid();
                    updateJSON();
                    return;
                }
                
                // Store NPC type for NPC spawns
                if (currentTool === 'npc-spawn') {
                    newTile.npcType = currentNpcType;
                    
                    // Automatically enable schedule mode and add first waypoint
                    scheduleMode = true;
                    document.getElementById('schedule-mode-toggle').checked = true;
                    document.getElementById('schedule-editor').style.display = 'block';
                    
                    // Select this NPC spawn for schedule editing
                    mapData.tiles.push(newTile);
                    selectNpcSpawnForSchedule(newTile);
                    
                    // Add the NPC spawn position as the first waypoint at 6:00 AM
                    const firstWaypointTime = 6 * 60; // 6:00 AM in minutes
                    addScheduleWaypoint(gridX, gridY, firstWaypointTime);
                    
                    // Set next waypoint time to 6:15 AM
                    document.getElementById('waypoint-time').value = '06:15';
                    
                    drawGrid();
                    updateJSON();
                    return; // Skip the regular push since we already added it
                }
                
                mapData.tiles.push(newTile);
            }
            
            drawGrid();
            updateJSON();
        }
        
        function handleCanvasHover(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Account for zoom and pan transforms (same logic as handleCanvasClick)
            const cellPixels = canvas.width / gridSize;
            const gridX = Math.floor((x - panX) / zoomLevel / cellPixels);
            const gridY = Math.floor((y - panY) / zoomLevel / cellPixels);
            
            // Update cursor position and redraw if changed
            if (cursorGridX !== gridX || cursorGridY !== gridY) {
                cursorGridX = gridX;
                cursorGridY = gridY;
                drawGrid();
            }
            
            canvas.title = `Grid: (${gridX}, ${gridY}) | World: (${(gridX - gridSize/2) * CELL_SIZE}, ${(gridY - gridSize/2) * CELL_SIZE}) | Rotation: ${currentRotation}¬∞`;
        }
        
        function forceRedrawPreview() {
            // Force a redraw of the grid and preview
            if (cursorGridX >= 0 && cursorGridY >= 0) {
                drawGrid();
            }
        }
        
        // Schedule editing helper functions
        function getNpcScheduleKey(npcTile) {
            return `${npcTile.gridX}_${npcTile.gridY}`;
        }
        
        function selectNpcSpawnForSchedule(npcTile) {
            selectedNpcSpawn = npcTile;
            const scheduleKey = getNpcScheduleKey(npcTile);
            if (!npcSchedules.has(scheduleKey)) {
                npcSchedules.set(scheduleKey, []);
            }
            updateScheduleList();
        }
        
        function timeStringToMinutes(timeStr) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }
        
        function minutesToTimeString(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
        }
        
        function getLastWaypointTime() {
            if (!selectedNpcSpawn) return 0;
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            if (waypoints.length === 0) return 0;
            return Math.max(...waypoints.map(w => w.timeMinutes));
        }
        
        function addScheduleWaypoint(gridX, gridY, timeMinutes) {
            if (!selectedNpcSpawn) return;
            
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            
            // Calculate world position
            const worldX = (gridX - gridSize / 2) * CELL_SIZE;
            const worldZ = (gridY - gridSize / 2) * CELL_SIZE;
            
            waypoints.push({
                gridX,
                gridY,
                worldX,
                worldZ,
                timeMinutes,
                timeString: minutesToTimeString(timeMinutes)
            });
            
            // Sort by time
            waypoints.sort((a, b) => a.timeMinutes - b.timeMinutes);
            npcSchedules.set(scheduleKey, waypoints);
            
            updateScheduleList();
        }
        
        function updateScheduleList() {
            const listDiv = document.getElementById('schedule-list');
            if (!selectedNpcSpawn) {
                listDiv.innerHTML = '<em style="color: #999;">No NPC selected</em>';
                return;
            }
            
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            
            if (waypoints.length === 0) {
                listDiv.innerHTML = '<em style="color: #999;">No waypoints yet</em>';
                return;
            }
            
            listDiv.innerHTML = waypoints.map((wp, idx) => `
                <div style="padding: 5px; margin: 2px 0; background: #3a3a3a; border-radius: 3px; display: flex; justify-content: space-between; align-items: center;">
                    <span>${idx + 1}. ${wp.timeString} - (${wp.gridX}, ${wp.gridY})</span>
                    <button onclick="removeWaypoint(${idx})" style="padding: 2px 8px; background: #d32f2f; color: white; border: none; border-radius: 3px; cursor: pointer;">√ó</button>
                </div>
            `).join('');
        }
        
        function removeWaypoint(index) {
            if (!selectedNpcSpawn) return;
            const scheduleKey = getNpcScheduleKey(selectedNpcSpawn);
            const waypoints = npcSchedules.get(scheduleKey) || [];
            waypoints.splice(index, 1);
            npcSchedules.set(scheduleKey, waypoints);
            updateScheduleList();
            drawGrid();
        }
        
        function updateJSON() {
            // Group tiles by type for better organization
            const groupedData = {
                metadata: mapData.metadata,
                buildings: [],
                spawns: {
                    player: [],
                    npcs: []
                }
            };
            
            mapData.tiles.forEach(tile => {
                if (tile.type === 'player-spawn') {
                    const playerSpawn = {
                        x: tile.worldX,
                        y: 0,
                        z: tile.worldZ
                    };
                    // Add rotation if present
                    if (tile.rotation !== undefined && tile.rotation !== 0) {
                        playerSpawn.rotation = tile.rotation;
                    }
                    groupedData.spawns.player.push(playerSpawn);
                } else if (tile.type === 'npc-spawn') {
                    const npcSpawn = {
                        x: tile.worldX,
                        y: 0,
                        z: tile.worldZ,
                        npcId: tile.npcType || "baker" // Use stored npcType, default to baker
                    };
                    // Add rotation if present
                    if (tile.rotation !== undefined && tile.rotation !== 0) {
                        npcSpawn.rotation = tile.rotation;
                    }
                    
                    // Add schedule if it exists
                    const scheduleKey = getNpcScheduleKey(tile);
                    const waypoints = npcSchedules.get(scheduleKey);
                    if (waypoints && waypoints.length > 0) {
                        npcSpawn.schedule = {};
                        waypoints.forEach(wp => {
                            // Convert time in minutes to seconds for the schedule format
                            const timeInSeconds = wp.timeMinutes * 60;
                            npcSpawn.schedule[timeInSeconds] = {
                                x: wp.worldX,
                                y: 0,
                                z: wp.worldZ
                            };
                        });
                    }
                    
                    groupedData.spawns.npcs.push(npcSpawn);
                } else {
                    const building = {
                        type: tile.type,
                        position: {
                            x: tile.worldX,
                            y: 0,
                            z: tile.worldZ
                        },
                        gridPosition: {
                            x: tile.gridX,
                            y: tile.gridY
                        }
                    };
                    
                    // Add rotation if present
                    if (tile.rotation !== undefined && tile.rotation !== 0) {
                        building.rotation = tile.rotation;
                    }
                    
                    groupedData.buildings.push(building);
                }
            });
            
            document.getElementById('jsonOutput').value = JSON.stringify(groupedData, null, 2);
        }
        
        function copyToClipboard() {
            const output = document.getElementById('jsonOutput');
            output.select();
            document.execCommand('copy');
            alert('Map data copied to clipboard!');
        }
        
        function downloadJSON() {
            const data = document.getElementById('jsonOutput').value;
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `map_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function clearMap() {
            if (confirm('Are you sure you want to clear the entire map?')) {
                mapData.tiles = [];
                drawGrid();
                updateJSON();
            }
        }
        
        // Initialize on load
        init();
    </script>
</body>
</html>
